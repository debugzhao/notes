### 一.七大原则

#### 开闭原则

1. 原则

   该原则规定在进行类的维护时尽量遵循对扩展开放，对修改关闭

#### 里氏替换原则

1. 原则

   子类可以扩展父类的功能，但是不能改变父类原有的功能

#### 合成复用原则

1. 原则

   该原则要求软件在复用时，尽量有限考虑组合/聚合方式来实现复用，其次再考虑用继承方式来实现复用。如何要以继承方式来实现复用则必要遵守里氏替换原则。合成复用原则和里氏替换原则两者相辅相成，都是对开闭原则规范的具体实现

2. 分类

   ​	通常类的复用分为两种，一种是继承复用，一种是组合/聚合复用

   1. 继承复用（缺点）

      1. 破坏了类的封装性

         因为继承会将父类的实现细节暴露给子类，父类对子类完全透明，因此继承复用也被称之为`白箱复用`

      2. 耦合度太高

         父类与子类之间的耦合度太高，父类的实现的任何改变都是影响到子类的变化，这不利于类的扩展和维护

      3. 限制了复用的灵活性

         子类从父类继承而来的实现是静态的，它在编译期就已经定义好了，因此不能改变

   2. 组合/聚合复用（优点）

      1. 维持了的封装性
      2. 降低了类的耦合度
      3. 提高了复用的灵活性

3. 实现方式

   合成复用原则是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用

### 二.创建型模式.

#### 创建型模式的特点和分类

1. 特点

   创建型模式的主要关注点是“怎样创建对象？”，它的主要特点是“将对象的创建与使用分离”。这样可以降低系统的耦合度，使用者不需要关注对象的创建细节，对象的创建由相关的工厂来完成

2. 分类

   1. 单例模式

      某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式

   2. 原型模式

      将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例

   3. 工厂方法模式

      定义一个用于创建产品的接口，由子类决定生产什么产品

   4. 抽象工厂模式

      提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品

   5. 建造者模式

      将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象

#### 单例模式

1. 单例模式特点

   1. 单例类中只有一个实例对象
   2. 该实例对象只能由该单例类创建
   3. 单例类对外提供一个访问该单例的全局访问点

2. 优点

   1. 单例模式可以保证内存里只有一个实例，减少了内存的开销
   2. 可以避免对资源的多重占用
   3. 单例模式设置全局访问点，可以优化和共享资源的访问

3. 引用场景

   1. 需要频繁创建的一些类，使用单例可以降低系统的内存压力，减少 GC
   2. 某类只要求生成一个对象的时候，如一个班中的班长、每个人的身份证号等
   3. 某类需要频繁实例化，而创建的对象又频繁被销毁的时候，如多线程的线程池、网络连接池等
   4. 当对象需要被共享的场合

4. 懒汉式和饿汉式

   1. 懒汉式

      什么时候调用getInstance方法，什么时候就创建该实例，懒汉式是非线程安全的，因此在设计的时候应该保证线程安全性

   2. 饿汉式

      类一加载就创建该单例，保证了在调用getInstance方法之前该单例就已经创建好了。因此饿汉式是线程安全的

#### 原型模式

1. 概念：

   用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象

   *原型对象需要实现Cloneable接口，否则会抛出异常*

2. 优点

   [Java](http://c.biancheng.net/java/) 自带的原型模式基于内存二进制流的复制，在性能上比直接 new 一个对象更加优良

   可以使用深克隆方式保存对象的状态

3. 分类

   1. 浅克隆

   2. 深克隆

      在Java中如果需要实现对象的深拷贝，可以通过序列化再反序列化的方式实现（将一个对象保存到流中，然后再从流中读取出来）。

      序列化实现深拷贝的原理：通过序列化实现的拷贝不仅可以复制对象本身，还可以复制原型对象的引用类型的成员变量

      *序列化对象需要实现Serializable接口*

#### 简单工厂模式

1. 应用场景

   对于产品种类较少的情况，可以考虑使用简单工厂模式实现创建产品。客户端只需要给工厂传入想要创建产品类型的参数然后使用产品就可以了，不需要知道创建产品的细节（具体实例的创建细节）。

   简单工厂模式实现客户端与具体产品之间的解耦

2. 系统结构

   <img src="https://i.loli.net/2020/09/26/U2ZudyvMohgsi5c.png" alt="image-20200926112641449" style="zoom:80%;" />

#### 工厂方法模式

1. 产生背景

   简单工厂模式违反了开闭原则，而工厂方法模式是对简单工厂模式的进一步抽象化，其好处是在不修改系统代码的情况下可以引进新的产品，即满足了开闭原则

2. 优点

   1. 用户只需要工厂的名字就可以得到对应的产品，无需知道产品的生产细节
   2. 灵活性增强，如果需要增加新的产品，只需添加产品类和对应的工厂类即可
   3. 解耦框架，高层模块只需要知道产品的抽象类即可，无序知道产品的实现类细节

3. 缺点

   1. 类的个数容易过多，增加了复杂度
   2. 增加了系统的抽象性和理解难度
   3. 抽象工厂只能产生出一种产品，此弊端可以用`抽象工厂模式`解决

4. 系统结构

   <img src="https://i.loli.net/2020/09/26/5aLIUwjC3KhDYEl.png" alt="image-20200926142752932" style="zoom:80%;" />

#### 抽象工厂模式

1. 概念

   抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品

2. 产品等级与产品组关系

   <img src="https://i.loli.net/2020/09/26/gy8WQZECAY67UIj.png" alt="image-20200926153933246" style="zoom:67%;" />

#### 建造者模式

### 三.结构型模式

#### 结构型模式概述

##### 概述

结构型模式描述了将类或者对象按照某种布局设计成更大的结构。它分为类结构模式和对象结构模式，类结构模式采用继承或者实现关系组织接口或者类，对象结构模式采用组合或者聚合关系来组织对象。

由于组合/聚合关系比继承关系的耦合度更低，满足`合成复用法则`，因此对象结构模式比类结构模式更加灵活

##### 7种结构型模式

1. 代理模式 `proxy`

   为某对象提供一个代理从而控制对该对象的直接访问。即客户端通过代理间接访问访问该对象，从而限制/增强/修改 该对象的一些属性

2. 适配器模式 `Adapter`

3. 桥接模式 `Bridge`

4. 装饰模式 `Decorator`

5. 外观模式 `Facade`

6. 享元模式 `Flyweight`

7. 组合模式 `Composite`

#### 代理模式

##### 概念

由于某些原因需要给某对象提供一个代理以控制对该对象的访问

##### 优点

1. 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用
2. 代理对象可以扩展目标对象的功能
3. 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性

##### 模式结构

1. 抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法
2. 真实主题（Real Subject）类
3. 代理（Proxy）类

#### 适配器模式

##### 概念

将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。

##### 分类

1. 类结构模式（通过继承关系实现，耦合度较高）
2. 对象结构模式（通过组合/聚合关系实现，耦合度较低）



桥接模式

装饰模式

外观模式

享元模式

组合模式

### 四.行为型模式

行为型模式概述

模板方法模式

策略模式

命令模式

责任链模式

状态模式

观察者模式

中介者模式

迭代器模式

访问者模式

备忘录模式

解释器模式

