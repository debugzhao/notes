# [MySQL实战宝典](https://github.com/debugzhao/geek-time/blob/main/book/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%98%E5%AE%9D%E5%85%B8/00%20%E5%BC%80%E7%AF%87%E8%AF%8D%20%20%E4%BB%8E%E4%B8%9A%E5%8A%A1%E5%87%BA%E5%8F%91%EF%BC%8C%E5%BC%80%E5%90%AF%E6%B5%B7%E9%87%8F%20MySQL%20%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.md)

### 00 从业务出发，开启海量 MySQL 架构设计

总的来说，我通过表结构设计、索引设计、高可用架构设计、分布式架构设计，由浅入深、循序渐进地与你一起**打造出一个能支撑海量的并发访问的分布式 MySQL 架构。**

1. 表结构设计

   以实际的业务为案例分析，先带你**分析不同字段类型的选型**，然后再学习 MySQL 中表的设计，比如表结构设计、访问设计、物理存储设计

2. 索引设计

   讲述索引的基本原理，层层推进到索引的创建和优化，最后触达**复杂 SQL 索引的设计与调优**，比如**多表 JOIN、子查询、分区表**的问题。

3. 高可用架构设计

   MySQL 作为一个开源的数据库，虽然提供了大量的高可用解决方案，但或多或少存在不少问题。这一章节层层递进，手把手教你搭建一个**完整的、可靠的、符合各种业务类型的高可用解决方案**。

4. 分布式架构设计

   将会从分布式架构概述、分布式表结构设计、分布式索引设计、分布式事务等角度展开。相信我，学完这部分内容，你会觉得分布式并不是一个很难的架构，对于各种分布式架构中的难题，可以做到信手拈来。

### 01 数据类型：避免自增踩坑

1. 自增整型类型做主键，**务必使用类型 BIGINT，而非 INT**，后期表结构调整代价巨大

   INT 的范围最大在 **42 亿**的级别，在真实的互联网业务场景的应用中，很容易达到最大值。例如一些流水表、日志表，每天 1000W 数据量，420 天后，INT 类型的上限即可达到。

   因此，（敲黑板 1）**用自增整型做主键，一律使用 BIGINT，而不是 INT**。不要为了节省 4 个字节使用 INT，当达到上限时，再进行表结构的变更，将是巨大的负担与痛苦。

2. MySQL 8.0 版本前，自增整型会有回溯问题，**做业务开发的你一定要了解这个问题**

3. 当达到自增整型类型的上限值时，再次自增插入，MySQL 数据库会报重复错误

4. 不要再使用浮点类型 Float、Double，MySQL 后续版本将不再支持上述两种类型

5. 账户余额字段，设计是用整型类型，而不是 DECIMAL 类型，这样性能更好，存储更紧凑

   在海量互联网业务的设计标准中，并不推荐用 DECIMAL 类型，而是**更推荐将 DECIMAL 转化为 整型类型**。也就是说，资金类型更推荐**使用用分单位存储，而不是用元单位存储**。如1元在数据库中用整型类型 100 存储。

   用户的金额至少要存储百亿的字段，而统计局的 GDP 金额字段则可能达到数十万亿级别。用类型 DECIMAL 定义，不好统一。

   另外重要的是，**类型 DECIMAL 是通过二进制实现的一种编码方式，计算效率远不如整型来的高效。**因此，推荐使用 BIG INT 来存储金额相关的字段。

   注意，在数据库设计中，我们非常强调定长存储，因为**定长存储的性能更好**。（若发生更新，记录 1 原先的空间无法容纳更新后记录 1 的存储空间，因此，这时数据库会将记录 1 标记为删除，寻找新的空间给记录1使用。而这个空间后续将变成碎片空间，无法继续使用，除非人为地进行表空间的碎片整理。）

###  02 字符串类型，不能忽略的排序规则

推荐把 MySQL 的默认字符集设置为 UTF8MB4，可以存储emoji类的字符。**排序规则（Collation）是比较和排序字符串的一种规则**，每个字符集都会有默认的排序规则。

```sql
mysql> SHOW CHARSET LIKE 'utf8%';

+---------+---------------+--------------------+--------+

| Charset | Description   | Default collation  | Maxlen |

+---------+---------------+--------------------+--------+

| utf8    | UTF-8 Unicode | utf8_general_ci    |      3 |

| utf8mb4 | UTF-8 Unicode | utf8mb4_0900_ai_ci |      4 |

+---------+---------------+--------------------+--------+
```

排序规则以 _ci 结尾，**表示不区分大小写（Case Insentive）**，_cs 表示大小写敏感，_bin 表示通过存储字符的二进制进行比较。需要注意的是，比较 MySQL 字符串，**默认采用不区分大小的排序规则**



