# [MySQL实战宝典](https://github.com/debugzhao/geek-time/blob/main/book/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%98%E5%AE%9D%E5%85%B8/00%20%E5%BC%80%E7%AF%87%E8%AF%8D%20%20%E4%BB%8E%E4%B8%9A%E5%8A%A1%E5%87%BA%E5%8F%91%EF%BC%8C%E5%BC%80%E5%90%AF%E6%B5%B7%E9%87%8F%20MySQL%20%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.md)

### 00 从业务出发，开启海量 MySQL 架构设计

总的来说，我通过表结构设计、索引设计、高可用架构设计、分布式架构设计，由浅入深、循序渐进地与你一起**打造出一个能支撑海量的并发访问的分布式 MySQL 架构。**

1. 表结构设计

   以实际的业务为案例分析，先带你**分析不同字段类型的选型**，然后再学习 MySQL 中表的设计，比如表结构设计、访问设计、物理存储设计

2. 索引设计

   讲述索引的基本原理，层层推进到索引的创建和优化，最后触达**复杂 SQL 索引的设计与调优**，比如**多表 JOIN、子查询、分区表**的问题。

3. 高可用架构设计

   MySQL 作为一个开源的数据库，虽然提供了大量的高可用解决方案，但或多或少存在不少问题。这一章节层层递进，手把手教你搭建一个**完整的、可靠的、符合各种业务类型的高可用解决方案**。

4. 分布式架构设计

   将会从分布式架构概述、分布式表结构设计、分布式索引设计、分布式事务等角度展开。相信我，学完这部分内容，你会觉得分布式并不是一个很难的架构，对于各种分布式架构中的难题，可以做到信手拈来。

### 01 数据类型：避免自增踩坑

1. 自增整型类型做主键，**务必使用类型 BIGINT，而非 INT**，后期表结构调整代价巨大

   INT 的范围最大在 **42 亿**的级别，在真实的互联网业务场景的应用中，很容易达到最大值。例如一些流水表、日志表，每天 1000W 数据量，420 天后，INT 类型的上限即可达到。

   因此，（敲黑板 1）**用自增整型做主键，一律使用 BIGINT，而不是 INT**。不要为了节省 4 个字节使用 INT，当达到上限时，再进行表结构的变更，将是巨大的负担与痛苦。

2. MySQL 8.0 版本前，自增整型会有回溯问题，**做业务开发的你一定要了解这个问题**

3. 当达到自增整型类型的上限值时，再次自增插入，MySQL 数据库会报重复错误

4. 不要再使用浮点类型 Float、Double，MySQL 后续版本将不再支持上述两种类型

5. 账户余额字段，设计是用整型类型，而不是 DECIMAL 类型，这样性能更好，存储更紧凑

   在海量互联网业务的设计标准中，并不推荐用 DECIMAL 类型，而是**更推荐将 DECIMAL 转化为 整型类型**。也就是说，资金类型更推荐**使用用分单位存储，而不是用元单位存储**。如1元在数据库中用整型类型 100 存储。

   用户的金额至少要存储百亿的字段，而统计局的 GDP 金额字段则可能达到数十万亿级别。用类型 DECIMAL 定义，不好统一。

   另外重要的是，**类型 DECIMAL 是通过二进制实现的一种编码方式，计算效率远不如整型来的高效。**因此，推荐使用 BIG INT 来存储金额相关的字段。

   注意，在数据库设计中，我们非常强调定长存储，因为**定长存储的性能更好**。（若发生更新，记录 1 原先的空间无法容纳更新后记录 1 的存储空间，因此，这时数据库会将记录 1 标记为删除，寻找新的空间给记录1使用。而这个空间后续将变成碎片空间，无法继续使用，除非人为地进行表空间的碎片整理。）

###  02 字符串类型：不能忽略的排序规则

推荐把 MySQL 的默认字符集设置为 UTF8MB4，可以存储emoji类的字符。**排序规则（Collation）是比较和排序字符串的一种规则**，每个字符集都会有默认的排序规则。

```sql
mysql> SHOW CHARSET LIKE 'utf8%';

+---------+---------------+--------------------+--------+

| Charset | Description   | Default collation  | Maxlen |

+---------+---------------+--------------------+--------+

| utf8    | UTF-8 Unicode | utf8_general_ci    |      3 |

| utf8mb4 | UTF-8 Unicode | utf8mb4_0900_ai_ci |      4 |

+---------+---------------+--------------------+--------+
```

排序规则以 _ci 结尾，**表示不区分大小写（Case Insentive）**，_cs 表示大小写敏感，_bin 表示通过存储字符的二进制进行比较。需要注意的是，比较 MySQL 字符串，**默认采用不区分大小的排序规则**

### 03 日期类型：timestamp可能是个巨坑

常见使用的日期类型为DATETIME 和 TIMESTAMP

- DATETIME 

  类型 DATETIME 最终展现的形式为：YYYY-MM-DD HH：MM：SS，固定占用 8 个字节。

- TIMESTAMP

  类型 TIMESTAMP 占用 4 个字节，因此其存储的时间上限只能到‘2038-01-19 03:14:07’。类型 TIMESTAMP **最大的优点是可以带有时区属性**，因为它本质上是从毫秒转化而来。

**总的来说，我建议你使用类型 DATETIME。** 对于时区问题，可以由前端或者服务这里做一次转化，不一定非要在数据库中解决。

不要忽视 TIMESTAMP 的性能问题

- **性能不如 DATETIME：** DATETIME 不存在时区转化问题
- **性能抖动：** 海量并发时，存在性能抖动问题

### 04 非结构存储：用好JSON这张牌

到目前为止，可能很多同学会把 JSON 当作一个很大的字段串类型，从表面上来看，没有错。但本质上**JSON 是一种新的类型**，有自己的存储格式，**还能在每个对应的字段上创建索引，做特定的优化，这是传统字段串无法实现的。**JSON 类型的另一个好处是**无须预定义字段**，字段可以无限扩展。

### 05 主键设计

使用 BIGINT 的自增类型作为主键的设计仅仅适合**非核心业务表**，比如告警表、日志表等。**真正的核心业务表，一定不要用自增键做主键**，主要有 6 个原因：

- 自增存在回溯问题
- 自增值在服务器端产生，存在并发性能问题
- 自增值做主键，只能在当前实例中保证唯一，**不能保证全局唯一**
- 公开数据值，容易引发安全问题，例如知道地址[http://www.example.com/User/10/](http://www.example.com/customers/10/?fileGuid=xxQTRXtVcqtHK6j8)，很容猜出 User 有 11、12 依次类推的值，容易引发数据泄露

因此，在互联网海量并发架构实战中，**我更推荐 UUID 做主键或业务自定义生成主键。**

#### 自定义业务生成主键

当然了，UUID 虽好，但是在分布式数据库场景下，主键还需要加入一些额外的信息，这样才能**保证后续二级索引的查询效率**。**现在你只需要牢记：分布式数据库架构，仅用 UUID 做主键依然是不够的。** 所以，对于分布式架构的核心业务表，我推荐类似如下的设计，比如：

```shell
PK = 时间字段 + 随机码（可选） + 业务信息1 + 业务信息2 ......
```

订单号显然是订单表的主键，但如果你以为订单号是自增整型，那就大错特错了。因为如果你仔细观察的话，可以发现图中所有订单号的后 6 位都是相同的，都为**308113**：

```shell
1550672064762308113

1481195847180308113

1431156171142308113

1431146631521308113
```

所以，我认为淘宝订单号的**最后 6 位是用户 ID 相关信息**，前 14 位是时间相关字段，这样能保证插入的自增性，又能同时保留业务的相关信息作为后期的分布式查询。

#### 总结

- 自增主键只推荐用在非核心业务表，甚至应避免使用
- 核心业务表推荐使用 UUID 或业务自定义主键
- 在分布式数据库架构中，UUID依然满足不了需求，需要自定义业务主键，保证主键自增的同时还能提高二级索引的查询效率
- 在一些场景下，可以通过 JSON 数据类型进行反范式设计，提升存储效率

### 06 表压缩：不仅仅是压缩空间

很多同学不会在表结构设计之初就考虑存储的设计，只有当业务发展到一定规模才会意识到问题的严重性。而物理存储主要是考虑是否要启用表的压缩功能，**默认情况下，所有表都是非压缩的。**

但一些同学一听到压缩，总会下意识地认为压缩会导致 MySQL 数据库的性能下降。**这个观点说对也不对，需要根据不同场景进行区分**

#### 表压缩

数据库中的表是由一行行记录（rows）所组成，每行记录被存储在一个页中，在 MySQL 中，**一个页的大小默认为 16K**，一个个页又组成了每张表的表空间。通常我们认为，**如果一个页中存放的记录数越多，数据库的性能越高**。这是因为数据库表空间中的页是存放在磁盘上，**MySQL 数据库先要将磁盘中的页读取到内存缓冲池**，然后以页为单位来读取和管理记录。

一个页中存放的记录越多，内存中能存放的记录数也就越多，那么存取效率也就越高。若想将一个页中存放的记录数变多，可以**启用压缩功能**。此外，启用压缩后，存储空间占用也变小了，同样单位的存储能存放的数据也变多了。

若要启用压缩技术，数据库可以根据记录、页、表空间进行压缩，不过在实际工程中，**我们普遍使用页压缩技术**，这是为什么呢？

- 基于记录压缩

  **因为每次读写都要压缩和解压，过于依赖 CPU 的计算能力，性能会明显下降**；另外，因为单条记录大小不会特别大，一般小于 1K，压缩效率也并不会特别好。

- 基于表空间压缩

  压缩效率非常不错，但要求表空间文件静态不增长，这对基于磁盘的关系型数据库来说，很难实现。

- 基于数据页压缩

  而基于页的压缩，既能提升压缩效率，又能在性能之间取得一种平衡。

的确，压缩需要消耗额外的 CPU 指令，但是压缩并不意味着性能下降，或许能额外提升性能，**因为大部分的数据库业务系统，CPU 的处理能力是剩余的，而 I/O 负载才是数据库主要瓶颈。**

借助页压缩技术，MySQL 可以把一个 16K 的页压缩为 8K，甚至 4K，这样在从磁盘写入或读取时，就能将 I/O 请求大小减半，甚至更小，从而提升数据库的整体性能。但无论如何，压缩都可以有效整理数据原本的容量，**对存储空间来说，压缩的收益是巨大的。**

#### MySQL表压缩设计

- COMPRESS 页压缩
	
	COMPRESS 页压缩是 MySQL 5.7 版本之前提供的页压缩功能。只要在创建表时指定ROW_FORMAT=COMPRESS，并设置通过选项 KEY_BLOCK_SIZE 设置压缩的比例。**需要牢记的是，** 虽然是通过选项 ROW_FORMAT 启用压缩功能，但这并不是记录级压缩，依然是根据页的维度进行压缩。
	
	下面这是一张日志表，ROW_FROMAT 设置为 COMPRESS，表示启用 COMPRESS 页压缩功能，KEY_BLOCK_SIZE 设置为 8，表示将一个 16K 的页压缩为 8K。
	
	```sql
	CREATE TABLE Log (
	
	  logId BINARY(16) PRIMARY KEY,
	
	  ......
	
	)
	
	ROW_FORMAT=COMPRESSED
	
	KEY_BLOCK_SIZE=8
	```
	
	例如日志表、监控表、告警表等，压缩比例通常能达到 50% 左右。虽然 COMPRESS 压缩可以有效减小存储空间，**但 COMPRESS 页压缩的实现对性能的开销是巨大的，性能会有明显退化。主要原因是一个压缩页在内存缓冲池中，存在压缩和解压两个页。**
	
- TPC 压缩

  为了 解决COMPRESS压缩性能下降的问题，从MySQL 5.7 版本开始推出了 TPC 压缩功能。TPC（Transparent Page Compression）是 5.7 版本推出的一种新的页压缩功能，其**利用文件系统的空洞（Punch Hole）特性进行压缩**。可以使用下面的命令创建 TPC 压缩表：

  ```sql
  CREATE TABLE Transaction （
  
    transactionId BINARY(16) PRIMARY KEY,
  
    .....
  
  )
  # 压缩算法
  COMPRESSION=ZLIB | LZ4 | NONE;
  ```

  **要使用 TPC 压缩，首先要确认当前的操作系统是否支持空洞特性。**通常来说，当前常见的 Linux 操作系统都已支持空洞特性。

  空洞压缩的另一个好处是，它对数据库性能的侵入几乎是无影响的（小于 20%），**甚至可能还能有性能的提升。**

#### 表压缩在业务上的应用

总的来说，对一些对性能不敏感的业务表，例如日志表、监控表、告警表等，它们只对存储空间有要求，因此可以使用 COMPRESS 页压缩功能。在一些较为核心的流水业务表上，我更推荐使用 TPC压缩

**📢注意事项：**

通过命令 ALTER TABLE xxx COMPRESSION = ZLIB 可以启用 TPC 页压缩功能，但是这只对后续新增的数据会进行压缩，对于原有的数据则不进行压缩。所以上述ALTER TABLE 操作只是修改元数据，瞬间就能完成。

若想要对整个表进行压缩，需要执行 OPTIMIZE TABLE 命令：

```sql
ALTER TABLE Transaction202102 COMPRESSION=ZLIB；

OPTIMIZE TABLE Transaction202102;
```

#### 总结

- MySQL 中的压缩都是基于页的压缩
- COMPRESS 页压缩适合用于性能要求不高的业务表，如日志、监控、告警表等
- COMPRESS 页压缩内存缓冲池存在压缩和解压的两个页，会严重影响性能
- 对存储有压缩需求，又希望性能不要有明显退化，推荐使用 TPC 压缩
- 通过 ALTER TABLE 启用 TPC 压缩后（增量数据压缩），还需要执行命令 OPTIMIZE TABLE 才能立即完成空间的压缩（全量数据压缩）。

### 07 表的访问设计

### 08 索引：排序的艺术

### 09 索引组织表：万物皆索引

### 10 组合索引：用好性能提升10倍

### 11 索引出错：请理解CBO的工作原理

### 12 JOIN：到底能不能写JOIN

### 13 子查询：放心地使用子查询吧

### 14 分区表：哪些场景不建议使用分区表

### 15 MySQL复制：最简单也最容易出错的配置

### 16 读写分离设计：复制延迟？其实是你用错了



