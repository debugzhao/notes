# [MySQL实战宝典](https://github.com/debugzhao/geek-time/blob/main/book/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%98%E5%AE%9D%E5%85%B8/00%20%E5%BC%80%E7%AF%87%E8%AF%8D%20%20%E4%BB%8E%E4%B8%9A%E5%8A%A1%E5%87%BA%E5%8F%91%EF%BC%8C%E5%BC%80%E5%90%AF%E6%B5%B7%E9%87%8F%20MySQL%20%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.md)

### 00 从业务出发，开启海量 MySQL 架构设计

总的来说，我通过表结构设计、索引设计、高可用架构设计、分布式架构设计，由浅入深、循序渐进地与你一起**打造出一个能支撑海量的并发访问的分布式 MySQL 架构。**

1. 表结构设计

   以实际的业务为案例分析，先带你**分析不同字段类型的选型**，然后再学习 MySQL 中表的设计，比如表结构设计、访问设计、物理存储设计

2. 索引设计

   讲述索引的基本原理，层层推进到索引的创建和优化，最后触达**复杂 SQL 索引的设计与调优**，比如**多表 JOIN、子查询、分区表**的问题。

3. 高可用架构设计

   MySQL 作为一个开源的数据库，虽然提供了大量的高可用解决方案，但或多或少存在不少问题。这一章节层层递进，手把手教你搭建一个**完整的、可靠的、符合各种业务类型的高可用解决方案**。

4. 分布式架构设计

   将会从分布式架构概述、分布式表结构设计、分布式索引设计、分布式事务等角度展开。相信我，学完这部分内容，你会觉得分布式并不是一个很难的架构，对于各种分布式架构中的难题，可以做到信手拈来。

### 01 数据类型：避免自增踩坑

1. 自增整型类型做主键，**务必使用类型 BIGINT，而非 INT**，后期表结构调整代价巨大

   INT 的范围最大在 **42 亿**的级别，在真实的互联网业务场景的应用中，很容易达到最大值。例如一些流水表、日志表，每天 1000W 数据量，420 天后，INT 类型的上限即可达到。

   因此，（敲黑板 1）**用自增整型做主键，一律使用 BIGINT，而不是 INT**。不要为了节省 4 个字节使用 INT，当达到上限时，再进行表结构的变更，将是巨大的负担与痛苦。

2. MySQL 8.0 版本前，自增整型会有回溯问题，**做业务开发的你一定要了解这个问题**

3. 当达到自增整型类型的上限值时，再次自增插入，MySQL 数据库会报重复错误

4. 不要再使用浮点类型 Float、Double，MySQL 后续版本将不再支持上述两种类型

5. 账户余额字段，设计是用整型类型，而不是 DECIMAL 类型，这样性能更好，存储更紧凑

   在海量互联网业务的设计标准中，并不推荐用 DECIMAL 类型，而是**更推荐将 DECIMAL 转化为 整型类型**。也就是说，资金类型更推荐**使用用分单位存储，而不是用元单位存储**。如1元在数据库中用整型类型 100 存储。

   用户的金额至少要存储百亿的字段，而统计局的 GDP 金额字段则可能达到数十万亿级别。用类型 DECIMAL 定义，不好统一。

   另外重要的是，**类型 DECIMAL 是通过二进制实现的一种编码方式，计算效率远不如整型来的高效。**因此，推荐使用 BIG INT 来存储金额相关的字段。

   注意，在数据库设计中，我们非常强调定长存储，因为**定长存储的性能更好**。（若发生更新，记录 1 原先的空间无法容纳更新后记录 1 的存储空间，因此，这时数据库会将记录 1 标记为删除，寻找新的空间给记录1使用。而这个空间后续将变成碎片空间，无法继续使用，除非人为地进行表空间的碎片整理。）

###  02 字符串类型：不能忽略的排序规则

推荐把 MySQL 的默认字符集设置为 UTF8MB4，可以存储emoji类的字符。**排序规则（Collation）是比较和排序字符串的一种规则**，每个字符集都会有默认的排序规则。

```sql
mysql> SHOW CHARSET LIKE 'utf8%';

+---------+---------------+--------------------+--------+

| Charset | Description   | Default collation  | Maxlen |

+---------+---------------+--------------------+--------+

| utf8    | UTF-8 Unicode | utf8_general_ci    |      3 |

| utf8mb4 | UTF-8 Unicode | utf8mb4_0900_ai_ci |      4 |

+---------+---------------+--------------------+--------+
```

排序规则以 _ci 结尾，**表示不区分大小写（Case Insentive）**，_cs 表示大小写敏感，_bin 表示通过存储字符的二进制进行比较。需要注意的是，比较 MySQL 字符串，**默认采用不区分大小的排序规则**

### 03 日期类型：timestamp可能是个巨坑

常见使用的日期类型为DATETIME 和 TIMESTAMP

- DATETIME 

  类型 DATETIME 最终展现的形式为：YYYY-MM-DD HH：MM：SS，固定占用 8 个字节。

- TIMESTAMP

  类型 TIMESTAMP 占用 4 个字节，因此其存储的时间上限只能到‘2038-01-19 03:14:07’。类型 TIMESTAMP **最大的优点是可以带有时区属性**，因为它本质上是从毫秒转化而来。

**总的来说，我建议你使用类型 DATETIME。** 对于时区问题，可以由前端或者服务这里做一次转化，不一定非要在数据库中解决。

不要忽视 TIMESTAMP 的性能问题

- **性能不如 DATETIME：** DATETIME 不存在时区转化问题
- **性能抖动：** 海量并发时，存在性能抖动问题

### 04 非结构存储：用好JSON这张牌

到目前为止，可能很多同学会把 JSON 当作一个很大的字段串类型，从表面上来看，没有错。但本质上**JSON 是一种新的类型**，有自己的存储格式，**还能在每个对应的字段上创建索引，做特定的优化，这是传统字段串无法实现的。**JSON 类型的另一个好处是**无须预定义字段**，字段可以无限扩展。

### 05 主键设计

使用 BIGINT 的自增类型作为主键的设计仅仅适合**非核心业务表**，比如告警表、日志表等。**真正的核心业务表，一定不要用自增键做主键**，主要有 6 个原因：

- 自增存在回溯问题
- 自增值在服务器端产生，存在并发性能问题
- 自增值做主键，只能在当前实例中保证唯一，**不能保证全局唯一**
- 公开数据值，容易引发安全问题，例如知道地址[http://www.example.com/User/10/](http://www.example.com/customers/10/?fileGuid=xxQTRXtVcqtHK6j8)，很容猜出 User 有 11、12 依次类推的值，容易引发数据泄露

因此，在互联网海量并发架构实战中，**我更推荐 UUID 做主键或业务自定义生成主键。**

#### 自定义业务生成主键

当然了，UUID 虽好，但是在分布式数据库场景下，主键还需要加入一些额外的信息，这样才能**保证后续二级索引的查询效率**。**现在你只需要牢记：分布式数据库架构，仅用 UUID 做主键依然是不够的。** 所以，对于分布式架构的核心业务表，我推荐类似如下的设计，比如：

```shell
PK = 时间字段 + 随机码（可选） + 业务信息1 + 业务信息2 ......
```

订单号显然是订单表的主键，但如果你以为订单号是自增整型，那就大错特错了。因为如果你仔细观察的话，可以发现图中所有订单号的后 6 位都是相同的，都为**308113**：

```shell
1550672064762308113

1481195847180308113

1431156171142308113

1431146631521308113
```

所以，我认为淘宝订单号的**最后 6 位是用户 ID 相关信息**，前 14 位是时间相关字段，这样能保证插入的自增性，又能同时保留业务的相关信息作为后期的分布式查询。

#### 总结

- 自增主键只推荐用在非核心业务表，甚至应避免使用
- 核心业务表推荐使用 UUID 或业务自定义主键
- 在分布式数据库架构中，UUID依然满足不了需求，需要自定义业务主键，保证主键自增的同时还能提高二级索引的查询效率
- 在一些场景下，可以通过 JSON 数据类型进行反范式设计，提升存储效率
