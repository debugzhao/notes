---
typora-root-url: imgs
---

### 进程与线程

#### 进程和线程

#### 进程

- 进程由`指令`和`数据`组成。一个进程的运行需要将指令加载进CPU、数据加载进内存。在进程运行过程中还需要用到磁盘、网络等设备。综上，进程是用来加载指令、管理内存、管理IO的程序集
- 当一个程序运行时，从磁盘加载这个程序的代码至内存，这时也就开启了一个进程
- 进程也可以理解为一个程序的实例。大部分程序可以运行多个进程实例（记事本、浏览器），当然有个程序只能运行一个进程实例（微信、网易云音乐）

##### 线程

- 一个进程之内可以运行多个线程
- 一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给CPU执行
- 线程是CPU调度的最小单位

##### 二者对比

- 进程之间相互独立。线程存在于进程的内部，是进程的一个子集
- 进程拥有共享资源，如内存空间，供其内部的线程共享使用
- 进程之间的通信比较复杂
    - 同一台计算机内的进程通信称为IPC（Inter Process Communication）通信
    - 不同计算机之间的进程通信，需要经过网络通信，并且遵守一定的协议（HTTP协议）
- 线程之间通信比较简单，因为它们共享进程的内存空间（eg：多个线程可以访问同一个共享变量）
- 线程更加轻量级，线程的上下切换的开销一般要比进程之间的上下文切换开销低

#### 并发与并行

##### 并发

单核CPU下，多个线程实际还是`串行执行`的。操作系统中有一个组件叫做`任务调度器`，可以将CPU的时间片（Windows下时间片最小为15毫秒）划分给不同的线程使用，由于CPU在不同之间的时间片切换是非常快的，对用户来说感知不到这个切换的过程，因此用户感觉线程是并行运行的。

总结：*微观串行，宏观并行*

<img src="C:\Users\lucas.zhao\AppData\Roaming\Typora\typora-user-images\image-20210615180503082.png" alt="image-20210615180503082" style="zoom:50%;" />

一般将线程轮流使用CPU的做法称之为并发（Concurrent）

##### 并行

多核CPU下，每个核心都可以调度运行线程，这个时候线程可以是并行的（Parallel）

##### 应用之异步调用

从方法的调用角度来讲，如果**需要等待**方法的结果才可以继续运行，这就是**同步**；如果**不需要等待**方法的结果就可以继续运行，这种就是**异步**

设计：多线程的使用可以让方法的执行变成异步的

##### 应用之提高效率

### 3. Java线程

#### 本章内容

1. 创建和运行线程
2. 查看线程
3. 线程API
4. 线程状态

#### 3.1 创建和运行线程

##### Thread

```java
@Slf4j(topic = "c.test")
public class TheadTest {
    public static void main(String[] args) {
        Thread thread = new Thread() {
            @Override
            public void run() {
                log.info("running...");
            }
        };
        thread.start();
        log.info("test");
    }
}
```

##### Runnable

```java
@Slf4j(topic = "RunnableTest")
public class RunnableTest {
    public static void main(String[] args) {
        Runnable runnable = new Runnable(){
            @Override
            public void run() {
                log.info("running...");
            }
        };
        Thread thread = new Thread(runnable, "t1");
        thread.start();

        lambda();
    }

    private static void lambda() {
        Thread thead1 = new Thread(() -> log.info("lambda test..."), "thead1");
        thead1.start();
    }
}
```

#### 3.2 查看和杀死进程

##### Windows

1. tasklist 查看进程

2. taskkill杀死进程

   ```shell
   tasklist | findstr java
   taskkill /F /PID 进程id
   ```

3. jps 查看java进程

##### Linux

1. ps -ef 查看所有进程信息
2. ps -fT -p <PID> 查看某个进程的所有线程信息
3. kill 杀死进程
4. top 实时查看进程信息
5. top -H -p <PID> 查看某个进程的所有线程信息

##### Java

1. jps 查看所有java进程

2. jstack <PID> 查看java进程的线程状态

3. jconsole 查看某个java进程的所有线程运行状态（图形化界面）

4. jconsole 远程监控配置

   ```shell
   java -Djava.rmi.server.hostname=`ip地址` -Dcom.sun.management.jmxremote -
   Dcom.sun.management.jmxremote.port=`连接端口` -Dcom.sun.management.jmxremote.ssl=是否安全连接 -
   Dcom.sun.management.jmxremote.authenticate=是否认证 java类
   ```

#### 3.3 线程运行原理

##### 栈和栈帧

我们都知道JVM由栈内存、堆内存、方法区构成。每个线程启动的时候JVM就会划分一部分栈内存给线程使用。

1. 其中每个栈由多个栈帧(Frame)构成，对应着每个方法调用时所占用的内存
2. 每个线程只有一个活动的栈帧，对应着当前正在执行的那个方法

##### 线程上下文切换

可能以下原因的出现导致CPU不在执行当前线程，转而执行其他线程

1. 线程的CPU时间片用完
2. 垃圾回收
3. 有更高优先级的线程抢先执行
4. 线程自己调用了sleep、wait、yield、join、park、synchronized、park等方法导致释放了CPU资源

当发生上下文切换时，需要由操作系统保存当前线程的执行状态，并且恢复另外一个线程的状态。在java中对应的就是`程序计数器`去记录该状态（线程私有）

#### 3.4 线程的常见方法

| 方法名            | static | 功能说明                                                 | 注意                                                         |
| ----------------- | ------ | -------------------------------------------------------- | ------------------------------------------------------------ |
| start()           |        | 启动一个新线程，在新线程中运行run 方法中的代码           |                                                              |
| run()             |        | 新线程启动后会调用该方法中的代码                         |                                                              |
| join()            |        | 等待线程运行结束                                         |                                                              |
| join(long)        |        | 指定一段时间后（时间单位：秒）等待线程运行结束           |                                                              |
| getId()           |        | 获取线程id                                               |                                                              |
| getName()         |        | 获取线程名称                                             |                                                              |
| setName()         |        | 设置线程名称                                             |                                                              |
| getPriority()     |        | 获取线程优先级                                           |                                                              |
| setPriority(int ) |        | 设置线程优先级                                           |                                                              |
| getState()        |        | 获取线程运行状态                                         | Java线程中有六个状态（用enum表示）分别是：NEW、RUNNABLE、BLOCKED、WAITING、TIMED_WAITING、TERMINATED |
| isInterrupted()   |        | 判断线程是否被打断                                       | 不会清除`打断标记`                                           |
| isAlive()         |        | 线程是否存活                                             |                                                              |
| interrupt()       |        | 打断线程                                                 | 如果被打断线程处于sleep、wait、join状态这时会导致被打断线程抛出InterruptException，并且**清除打断标记**。<br />如果打断的是正在运行的线程，则会**设置打断标记**<br />处于park状态的线程被打断时也会**设置打断标记** |
| interrupted()     | static | 判断当前线程是否被打断                                   | **会清除打断标记**                                           |
| currentThread()   | static | 获取当前正在执行的线程                                   |                                                              |
| sleep(n)          | static | 使当前线程休眠n毫秒，休眠是让出cpu的时间片给其他线程使用 |                                                              |
| yield()           | static | 提示线程调度器让出当前线程对CPU的使用                    | 主要是为了测试和调度使用                                     |

#### 3.5 start() & run()

**区别：**直接调用run方法本质上主线程执行run方法里面的代码，并没有起到异步执行的作用；调用start方法的原理是：新开启一个线程，让新创建的线程去执行run方法的代码

```java
@Slf4j(topic = "StartRunTest")
public class StartRunTest {
    public static void main(String[] args) {
        Thread thread = new Thread("thread1") {
            @Override
            public void run() {
                log.info("thread1 running...");
            }
        };
        thread.run();
        log.info("main thread running...");
    }
}

12:37:33.792 [main] INFO StartRunTest - thread1 running...
12:37:33.794 [main] INFO StartRunTest - main thread running...
```

**线程启动前后的状态变化**

```java
 @Slf4j(topic = "ThreadStatusTest")
public class ThreadStatusTest {
    public static void main(String[] args) {
        Thread thread = new Thread("thread1") {
            @Override
            public void run() {
                log.info("thread1 running...");
            }
        };
        log.info("线程启动之前状态：{}", thread.getState());
        thread.start();
        log.info("线程启动之后状态：{}", thread.getState());
    }
}

12:47:28.068 [main] INFO ThreadStatusTest - 线程启动之前状态：NEW
12:47:28.074 [main] INFO ThreadStatusTest - 线程启动之后状态：RUNNABLE
12:47:28.075 [thread1] INFO ThreadStatusTest - thread1 running...
```

*一个线程如果处于`RUNNABLE`状态，则不能再次调用start方法，否则会抛异常*

#### 3.6 sleep() & yield()

##### sleep方法

1. 调用sleep方法会让线程从running状态切换为 timed waiting状态

2. 其他实现可以使用interrupt方法打断正在睡眠的线程，这是sleep方法会抛出 `InterruptException`

   ```java
   @Slf4j(topic = "Test7Interrupt")
   public class Test7Interrupt {
   
       public static void main(String[] args) throws InterruptedException {
           Thread thread = new Thread("thread1") {
               @Override
               public void run() {
                   log.info("thread1线程进入睡眠状态");
                   try {
                       Thread.sleep(2000);
                   } catch (InterruptedException e) {
                       log.info("thread1线程被唤醒");
                       e.printStackTrace();
                   }
               }
           };
           thread.start();
   
           Thread.sleep(1000);
           log.info("main线程开始打断 thread1线程");
           thread.interrupt();
       }
   }
   
   Connected to the target VM, address: '127.0.0.1:4839', transport: 'socket'
   15:22:23.271 [thread1] INFO Test7Interrupt - thread1线程进入睡眠状态
   15:22:24.270 [main] INFO Test7Interrupt - main线程开始打断 thread1线程
   15:22:24.270 [thread1] INFO Test7Interrupt - thread1线程被唤醒
   java.lang.InterruptedException: sleep interrupted
   Disconnected from the target VM, address: '127.0.0.1:4839', transport: 'socket'
   	at java.lang.Thread.sleep(Native Method)
   	at com.kuhan.ops.monitor.system.Test7Interrupt$1.run(Test7Interrupt.java:20)
   ```



3. 睡眠结束后的线程未必可以立即执行（只有抢占到时间片资源的线程才可以执行）

4. 建议使用TimeUnit的Sleep方法来代替Thread的Sleep方法，来提升可读性

##### yield方法

```java
Runnable task2 = () -> {
    int count = 0;
    while (true) {
        // 当前线程拿到时间片资源以后将其让出去，让给其他线程执行
        Thread.yield();
        System.out.println("        ------>task2: " + count ++);
    }
};
```

1. 调用yield方法会使当前线程从`RUNNING`执行状态切换为`RUNNABLE`就绪状态，然后调度执行其他线程
2. 具体的实现依赖操作系统的任务调度器

##### 区别

调用sleep方法之后线程处于`TIMED_WATIING`阻塞状态、调用yield方法之后线程处于`RUNNABLE`就绪状态，调度器会把时间片分给就绪状态的线程而不会分给阻塞状态的线程

##### 线程优先级

1. 线程优先级会提示调度器优先调度该线程，但是它仅仅是提示作用，因为线程调度器可以**忽略**它
2. 如果CPU比价忙，那么优先级高的线程有更多的机会获得时间片；但是如果CPU闲时，线程优先级几乎不起作用

```java
@Slf4j(topic = "Test8Yield")
public class Test8Yield {

    public static void main(String[] args){
        Runnable task1 = () -> {
          int count = 0;
          while (true) {
              System.out.println("------>task1: " + count ++);
          }
        };
        Runnable task2 = () -> {
            int count = 0;
            while (true) {
                // 当前线程拿到时间片资源以后将其让出去，让给其他线程执行
                // Thread.yield();
                System.out.println("        ------>task2: " + count ++);
            }
        };

        Thread thread1 = new Thread(task1, "task1");
        Thread thread2 = new Thread(task2, "task2");
        thread1.setPriority(Thread.MIN_PRIORITY);
        thread2.setPriority(Thread.MAX_PRIORITY);

        thread1.start();
        thread2.start();
    }
}
```

#### 3.7 join() 方法详解

> 等待线程运行结束

##### 为什么需要join

```java
@Slf4j(topic = "test10")
public class Test10 {

    private static int NUMBER = 0;

    public static void main(String[] args) {
        log.info("main start...");
        increase();
        log.info("main end...");
    }


    private static void increase() {
        new Thread(() -> {
            log.info("thread1 start...");
            try {
                TimeUnit.SECONDS.sleep(1);
                NUMBER ++;
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            log.info("thread1 end...");
        }, "thread1").start();
        log.info("number: {}", NUMBER);
    }
}
```

以上代码中main线程先于thread1线程执行完成之后就获取NUMBER的结果，所以NUMBER还是0

**使用join方法可以解决该问题：**

```java
@Slf4j(topic = "test10")
public class Test10 {

    private static int NUMBER = 0;

    public static void main(String[] args) throws InterruptedException {
        log.info("main start...");
        increase();
        log.info("main end...");
    }


    private static void increase() throws InterruptedException {
        Thread thread = new Thread(() -> {
            log.info("thread1 start...");
            try {
                TimeUnit.SECONDS.sleep(1);
                NUMBER++;
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            log.info("thread1 end...");
        }, "thread1");
        thread.start();
        thread.join();
        log.info("number: {}", NUMBER);
    }
}


16:38:55.374 [main] INFO test10 - main start...
16:38:55.419 [thread1] INFO test10 - thread1 start...
16:38:56.419 [thread1] INFO test10 - thread1 end...
16:38:56.419 [main] INFO test10 - number: 1
16:38:56.421 [main] INFO test10 - main end...
```

##### 应用之同步

##### 等待多个结果

##### 有时效的join

#### 3.8 interrupt方法详解

##### 打断处于阻塞状态的线程

打断处于sleep、wait、join状态（阻塞状态）的线程，会清除打断标记，并且会抛出`InterruptedException`异常

```java
@Slf4j(topic = "Test11Interrupt")
public class Test11Interrupt {
    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(() -> {
            log.info("sleep...");
            try {
                TimeUnit.SECONDS.sleep(3);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "thread1");

        thread.start();

        TimeUnit.SECONDS.sleep(1);
        log.info("interrupt...");
        thread.interrupt();
        log.info("thread interrupt state: {}", thread.isInterrupted());
    }
}

11:04:46.320 [thread1] INFO Test11Interrupt - sleep...
11:04:47.318 [main] INFO Test11Interrupt - interrupt...
11:04:47.318 [main] INFO Test11Interrupt - thread interrupt state: false
java.lang.InterruptedException: sleep interrupted
	at java.lang.Thread.sleep(Native Method)
	at java.lang.Thread.sleep(Thread.java:340)
	at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:386)
	at com.kuhan.ops.monitor.system.Test11Interrupt.lambda$main$0(Test11Interrupt.java:18)
	at java.lang.Thread.run(Thread.java:748)
Disconnected from the target VM, address: '127.0.0.1:10471', transport: 'socket'
```

##### 打断处于正常运行状态的线程。

主线程只是将子线程的打断标记置为真，但是并没有真正的终止子线程的任务，子线程可以根据自己的打断状态来自行终止线程任务

```java
@Slf4j(topic = "Test12Interrupt")
public class Test12Interrupt {
    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(() -> {
            while (true) {
                boolean isInterrupted = Thread.currentThread().isInterrupted();
                if(isInterrupted) {
                    log.info("thread1线程被主线程打断，终止执行任务...");
                    break;
                }
            }
        }, "thread1");
        thread.start();

        TimeUnit.SECONDS.sleep(1);
        log.info("interrupt...");
        thread.interrupt();
    }
}

11:23:45.895 [main] INFO Test12Interrupt - interrupt...
11:23:45.898 [thread1] INFO Test12Interrupt - thread1线程被主线程打断，终止执行任务...
```

##### interrupt使用场景

可以**优雅地停止**线程任务（让子线程自己判断是否需要停止线程任务）

#### 3.9 不推荐使用的方法

还有一些不推荐使用的方法，这些方法已经过时并且容易破坏同步代码块，造成线程死锁

| 方法名  | static | 功能说明             |
| ------- | ------ | -------------------- |
| stop    |        | 停止线程运行         |
| suspend |        | 挂起（暂停线程运行） |
| resume  |        | 恢复线程运行         |

#### 3.10 主线程与守护线程

##### 主线程

默认情况下Java线程即主线程需要等待所有其他子线程运行结束以后，才会结束运行

##### 守护线程

有一种特殊的线程叫做守护线程，只要其他非守护线程运行结束了，不管守护线程的代码有没有执行完，守护线程也会停止运行

```java
@Slf4j(topic = "Test12Interrupt")
public class Test14Daemon {
    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(() -> {
            while (true) {
                boolean isInterrupted = Thread.currentThread().isInterrupted();
                if(isInterrupted) {
                    break;
                }
            }
            log.info("终止执行任务...");
        }, "thread1");
        thread.setDaemon(true);
        thread.start();

        TimeUnit.SECONDS.sleep(1);
        log.info("主线程结束运行...");
    }
}
```

##### 守护线程应用场景

1. 垃圾回收线程就是守护线程，主要程序终止，垃圾回收线程无论工作有没有做完也会停止运行
2. Tomcat中的Acceptor和Poller线程也是守护线程。所有当Tomcat接收到shutdown命令之后，不会等待它处理完当前的请求就直接停止运行

#### 3.11 五种线程状态

这是从**操作系统**层面来描述的

<img src="D:\KUHAN Project\notes\doc\Java并发编程\imgs\线程五种运行状态.png" alt="线程五种运行状态" style="zoom:80%;" />

1. 初始状态（创建状态）

   仅仅在语言层面创建了线程对象，还未与操作系统相关联

2. 可运行状态（就绪状态）

   指该线程已经被创建（已经与操作系统关联），可以由CPU调度执行

3. 运行状态

   指线程获取了CPU时间片，处于正在运行中的状态

   当CPU时间片运行完，线程状态会从`运行状态`切换至`可运行状态`，会导致线程上下文的切换

4. 阻塞状态

   如果调用了阻塞API，这是线程不再会占用CPU资源，会导致线程的上下文切换，进入到阻塞状态

   阻塞结束之后，操作系统会唤醒处于阻塞状态的线程，线程切换至可运行状态

   与`可运行状态`的区别是，对于`阻塞状态`的线程来说只要他们一直`不被唤醒`，调度器就不会考虑给他们分配CPU资源

5. 终止状态

   表示线程执行结束，生命周期完结，不再会切换至其他状态

#### 3.12 六种线程状态

线程的六种状态是从**Java API**层面分析的

#### 3.13 烧水泡茶案例

<img src="D:\KUHAN Project\notes\doc\Java并发编程\imgs\案例：烧水泡茶.png" alt="案例：烧水泡茶" style="zoom:60%;" />

#### 3.14 本章小节

1. 线程的创建方式

2. 线程的重要API

   start run sleep join interrupt 

3. 线程状态

4. <font color='red'>应用方面</font>

   1. 异步调用

      主线程执行期间，其他线程执行一下耗时的操作

   2. 提高效率

      并行计算，缩短运算时间

   3. 同步等待

      使用join方法可以实现同步等待

   4. 统筹规划

      合理进行线程之间的调度，以达到最优的效果

5. <font color='red'>原理方面</font>

   线程运行流程：栈、栈帧、上下文切换、程序计数器

   Thread类的两种创建线程方式的源码

6. <font color='red'>模式方面</font>

   两阶段终止模式

### 4. 共享模型之管程

#### 本章内容

1. 共享问题
2. synchronized
3. 线程安全分析
4. Monitor（管程的底层实现）
5. wait/notify
6. 线程状态转换
7. 活跃性（死锁、活锁、饥饿）
8. Lock（对活跃性问题进行改进）

#### 4.1 共享带来的问题

多个线程同时**读写**共享变量，可能出现线程安全问题。

> 例如：线程1写完数据之后，由于时间片用完进入**阻塞状态**，导致其操作后的数据没有及时刷新进入**主存**，线程2这个时候拿到的之前旧的数据进行读写，这个时候就出现了线程安全问题。并且线程1、线程2都没有觉得自己做错

<img src="D:\KUHAN Project\notes\doc\Java并发编程\imgs\线程安全问题.png" alt="线程安全问题" style="zoom:60%;" />

##### Java代码实现

> 两个线程对初始值为0的静态变量一个做自增操作，一个做自减操作，分别执行5000次，最终的结果是0吗？

```java
@Slf4j(topic = "共享模型之管程")
public class Test16 {
    
    private static int NUMBER = 0;
    
    public static void main(String[] args) throws InterruptedException {
        Thread thread1 = new Thread("increase thread"){
            @Override
            public void run() {
                for (int i = 0; i < 5000; i++) {
                    NUMBER ++;
                }
            }
        };

        Thread thread2 = new Thread("decrease thread"){
            @Override
            public void run() {
                for (int i = 0; i < 5000; i++) {
                    NUMBER --;
                }
            }
        };

        thread1.start();
        thread2.start();
        
        thread1.join();
        thread2.join();
        log.info("最终执行结果：{}", NUMBER);
    }
}

17:02:17.416 [main] INFO 共享模型之管程 - 最终执行结果：-445
```

##### 问题分析

以上代码的执行结果可能为正数、负数、零。为什么会出现这种情况呢？因为在Java中对静态变量的自增、或者自减操作并不是原子操作，从字节码的角度分析如下：

对于 `i ++` （**i  为静态变量**）而言，实际会产生如下的**四个字节码指令**

```java
getstatic i   // 获取静态变量i的值
iconst_1      // 准备常量1
iadd          // 自增
putstatic i   // 将修改后的值存入静态变量i
```

**Java的内存模型如下：**

<img src="D:\KUHAN Project\notes\doc\Java并发编程\imgs\Java内存模型.png" alt="Java内存模型" style="zoom:60%;" />

##### 临界区 Critical Section

一个程序运行多个线程本身是没有问题的，问题出现在多个线程访问**共享资源**。多个线程对共享资源进行**读操作**也是没有问题的，如果多个线程对共享资源进行**写操作**可能出现**指令交错**的问题，也就是线程安全问题

 一个代码块内如果出现多个线程对共享资源进行**读写操作**，那么这个代码块称之为**临界区**

```java
static int counter = 0;

static void increment(){
 // 临界区
 counter++;
}
static void decrement(){
 // 临界区
 counter--;
}
```

##### 竞态条件 Race Condition

多个线程在临界区内执行，由于**代码的执行序列不同**（字节码的执行序列）而导致程序的结果无法预测，称之发生了竞态条件

#### 4.2 synchronized解决方案

##### ❗ 应用之互斥

为了避免在临界区内发生竞态条件，有以下两种方案可以解决该问题

1. 阻塞式解决方案：Synchronized、Lock
2. 非阻塞式解决方案：原子变量

本章节使用的是Synchronized解决方案解决竞态条件问题。Synchronized俗称**对象锁**，它采用的互斥机制让同一时刻最多有一个线程持有对象锁，其他线程再想获取对象锁就会被阻塞掉。这样就可以保证拥有锁的线程可以安全地执行临界区内的代码，而不用担心上下文切换的问题。

**注意**

虽然Java中**互斥**和**同步**都是基于Synchronized实现的，但是它们还是有区别的

1. 互斥是保证临界区的竞态条件发生时，同一时刻只能有一个线程执行临界区内的代码
2. 同步是由于线程的执行顺序不同，需要一个线程等待另一个线程运行到一个点

##### synchronized语法

```java
// 线程1， 线程2(blocked)
synchronized(对象) {
 // 临界区
}
```

```java
@Slf4j(topic = "共享模型之管程")
public class Test16fSynchronized {
    
    private static int NUMBER = 0;

    private final static Object LOCK = new Object();
    
    public static void main(String[] args) throws InterruptedException {
        Thread thread1 = new Thread("increase thread"){
            @Override
            public void run() {
                for (int i = 0; i < 5000; i++) {
                    synchronized (LOCK) {
                        NUMBER ++;
                    }
                }
            }
        };

        Thread thread2 = new Thread("decrease thread"){
            @Override
            public void run() {
                for (int i = 0; i < 5000; i++) {
                    synchronized (LOCK) {
                        NUMBER --;
                    }
                }
            }
        };

        thread1.start();
        thread2.start();
        
        thread1.join();
        thread2.join();
        log.info("最终执行结果：{}", NUMBER);
    }
}
```

##### 思考

synchronized本质使用**对象锁**保证了**临界区代码的原子性**，临界区内的代码对外是不可分割的，不会被线程的切换所打断

为了加深理解，请思考一下问题：

1. 如果把synchronized关键字放在for循环外面，会怎样？（原子性问题）

   synchronized关键字放在for的话，**保证了20000行 JVM字节码指令的原子性**。和保证4行字节码指令原子性格哪个**性能**更高？

2. 如果t1 是synchronized( obj1) 但是t2 synchronized( obj2)会怎样？（应该持有同一个锁对象）

   在使用synchronized时，我们应该保证不同线程锁的是同一个对象，否则临界区代码仍然会因为线程切换出现不能保证原子性问题，仍然会出现线程安全问题

3. 如果t1 是synchronized( obj1) 但是t2 没有使用synchronized会怎么样？（所有线程都应该持有同一个锁对象）

   t2线程没有加锁，所以在t1线程持有锁的时候，t1不会出现阻塞状态，仍然会出现线程安全问题

##### 面向对象改进

```java
@Slf4j(topic = "共享模型之管程")
public class Test17Synchronized {
    
    public static void main(String[] args) throws InterruptedException {

        Room room = new Room();

        Thread thread1 = new Thread("increase thread"){
            @Override
            public void run() {
                for (int i = 0; i < 5000; i++) {
                    room.increment();
                }
            }
        };

        Thread thread2 = new Thread("decrease thread"){
            @Override
            public void run() {
                for (int i = 0; i < 5000; i++) {
                    room.decrement();
                }
            }
        };

        thread1.start();
        thread2.start();
        
        thread1.join();
        thread2.join();
        log.info("最终执行结果：{}", room.getCounter());
    }
}

class Room {
    private int counter = 0;

    public void increment () {
        synchronized (this) {
            counter ++;
        }
    }

    public void decrement () {
        synchronized (this) {
            counter --;
        }
    }

    /**
     * 在进行读操作的时候也需要保证互斥，防止在其他线程写的过程中读取脏数据
     * @return 获取counter的数值
     */
    public int getCounter () {
        synchronized (this) {
            return counter;
        }
    }
}
```

#### 4.3 方法上的synchronized

##### synchronized方法

```java
class Test {
	// 普通成员方法
    public synchronized void increment () {
    }

    // 等价于 所得是this对象
    public void increment1 () {
        synchronized(this) {

        }
    }
}
```

```java
class Test {
	// 静态成员方法
    public synchronized static void increment2 () {

    }
	// increment2等价于increment3，所得是Test类
    public static void increment3 () {
        synchronized(Test.class) {

        }
    }
}
```

##### 所谓的“线程八锁”

其实就是考察的synchronized锁的是哪个对象

1. 情况1

   锁的是**this对象**

   输出 1 2 或者 2 1

   ```java
   // 
   public class Test18 {
       public static void main(String[] args) {
           Number number = new Number();
   
           new Thread(() -> {
               number.fun1();
           }).start();
           new Thread(() -> {
               number.fun2();
           }).start();
       }
   }
   
   @Slf4j(topic = "Number")
   class Number {
       /**
        * 锁的是this对象
        */
       public synchronized void fun1() {
           log.info("1");
       }
   
       public synchronized void fun2() {
           log.info("2");
       }
   }
   ```

2. 情况2 

   一秒后输出1 2，或者先输出2  然后一秒后输出1

   ```java
   @Slf4j(topic = "Test18")
   public class Test18 {
       public static void main(String[] args) {
           Number number = new Number();
   
           new Thread(() ->{
               log.info("thread1 begin");
               number.fun1();
           }).start();
           new Thread(() -> {
               log.info("thread2 begin");
               number.fun2();
           }).start();
       }
   }
   
   @Slf4j(topic = "Number")
   class Number {
       /**
        * 锁的是this对象
        */
       @SneakyThrows
       public synchronized void fun1() {
           TimeUnit.SECONDS.sleep(1);
           log.info("1");
       }
   
       public synchronized void fun2() {
           log.info("2");
       }
   }
   
   17:04:02.035 [Thread-0] INFO Test18 - thread1 begin
   17:04:02.035 [Thread-1] INFO Test18 - thread2 begin
   17:04:03.039 [Thread-0] INFO Number - 1
   17:04:03.039 [Thread-1] INFO Number - 2
   ```

3. fun3是同步方法，不存在互斥情况

   ```java
   // 3 1s后 12
   // 23 1s后 1
   // 32 1s后 1
   ```

   ```java
   @Slf4j(topic = "Test18")
   public class Test18 {
       public static void main(String[] args) {
           Number number = new Number();
   
           new Thread(() ->{
               log.info("thread1 begin");
               number.fun1();
           }).start();
           new Thread(() -> {
               log.info("thread2 begin");
               number.fun2();
           }).start();
           new Thread(() -> {
               log.info("thread3 begin");
               number.fun3();
           }).start();
       }
   }
   @Slf4j(topic = "Number")
   class Number {
       /**
        * 锁的是this对象
        */
       @SneakyThrows
       public synchronized void fun1() {
           TimeUnit.SECONDS.sleep(1);
           log.info("1");
       }
   
       public synchronized void fun2() {
           log.info("2");
       }
   
       public void fun3() {
           log.info("3");
       }
   }
   ```

4. 两个锁对象

   2 1s后 1

   ```java
   @Slf4j(topic = "Test18")
   public class Test18 {
       public static void main(String[] args) {
           Number number1 = new Number();
           Number number2 = new Number();
   
           new Thread(() ->{
               number1.fun1();
           }).start();
           new Thread(() -> {
               number2.fun2();
           }).start();
       }
   }
   
   @Slf4j(topic = "Number")
   class Number {
       /**
        * 锁的是this对象
        */
       @SneakyThrows
       public synchronized void fun1() {
           TimeUnit.SECONDS.sleep(1);
           log.info("1");
       }
   
       public synchronized void fun2() {
           log.info("2");
       }
   }
   ```

5. 两个锁对象（一个this锁对象、一个Number.class对象）**没有互斥**

   2 1s后 1

   ```java
   @Slf4j(topic = "Test18")
   public class Test18 {
       public static void main(String[] args) {
           Number number1 = new Number();
   
           new Thread(() ->{
               log.info("thread1 begin");
               number1.fun1();
           }).start();
           new Thread(() -> {
               log.info("thread2 begin");
               number1.fun2();
           }).start();
       }
   }
   
   @Slf4j(topic = "Number")
   class Number {
   
       /**
        * 锁的是 Number.class
        */
       @SneakyThrows
       public static synchronized void fun1() {
           TimeUnit.SECONDS.sleep(1);
           log.info("1");
       }
   
       /**
        * 锁的是this对象
        */
       public synchronized void fun2() {
           log.info("2");
       }
   }
   
   
   17:32:08.952 [Thread-1] INFO Test18 - thread2 begin
   17:32:08.952 [Thread-0] INFO Test18 - thread1 begin
   17:32:08.955 [Thread-1] INFO Number - 2
   17:32:09.955 [Thread-0] INFO Number - 1
   ```

6. 锁的是同一个Number.class对象（**有互斥**）
   2 1s后 1

   1s后 12

   ```java
   @Slf4j(topic = "Test18")
   public class Test18 {
       public static void main(String[] args) {
           Number number1 = new Number();
           new Thread(() -> number1.fun1()).start();
           new Thread(() -> number1.fun2()).start();
       }
   }
   
   @Slf4j(topic = "Number")
   class Number {
   
       /**
        * 锁的是 Number.class
        */
       @SneakyThrows
       public static synchronized void fun1() {
           TimeUnit.SECONDS.sleep(1);
           log.info("1");
       }
   
       /**
        * 锁的是 Number.class
        */
       public static synchronized void fun2() {
           log.info("2");
       }
   }
   
   17:34:10.758 [Thread-0] INFO Test18 - thread1 begin
   17:34:10.758 [Thread-1] INFO Test18 - thread2 begin
   17:34:11.761 [Thread-0] INFO Number - 1
   17:34:11.761 [Thread-1] INFO Number - 2
   ```

7. 线程1锁的是Number.class对象，线程2锁的是this对象，**不存在互斥现象**

   2 1s后 1

   ```java
   @Slf4j(topic = "Test18")
   public class Test18 {
       public static void main(String[] args) {
           Number number1 = new Number();
           Number number2 = new Number();
           new Thread(() -> number1.fun1()).start();
           new Thread(() -> number2.fun2()).start();
       }
   }
   
   @Slf4j(topic = "Number")
   class Number {
   
       /**
        * 锁的是 Number.class对象
        */
       @SneakyThrows
       public static synchronized void fun1() {
           TimeUnit.SECONDS.sleep(1);
           log.info("1");
       }
   
       /**
        * 锁的是 this对象
        */
       public synchronized void fun2() {
           log.info("2");
       }
   }
   ```

8. 线程1锁的是Number.class对象，线程2锁的是Number.class对象，（**有互斥**）

   2 1s后 1

   1s后 12

   ```java
   @Slf4j(topic = "Test18")
   public class Test18 {
       public static void main(String[] args) {
           Number number1 = new Number();
           Number number2 = new Number();
           new Thread(() -> number1.fun1()).start();
           new Thread(() -> number2.fun2()).start();
       }
   }
   
   @Slf4j(topic = "Number")
   class Number {
   
       /**
        * 锁的是 Number.class对象
        */
       @SneakyThrows
       public static synchronized void fun1() {
           TimeUnit.SECONDS.sleep(1);
           log.info("1");
       }
   
       /**
        * 锁的是 Number.class对象
        */
       @SneakyThrows
       public static synchronized void fun2() {
           log.info("2");
       }
   }
   ```

   

#### 4.4 变量的线程安全分析

##### 成员变量和静态变量是否线程安全？

1. 如果他们没有被共享，则线程安全
2. 如果他们被共享了，这是还要根据读写操作来确定线程安全的问题
   1. 如果只有读取操作，则线程安全
   2. 如果既有读操作、又有写操作，则这段代码是临界区，需要考虑线程安全问题

##### 局部变量是否线程安全？

1. 局部变量是线程安全的
2. 但是局部变量引用的对象未必是线程安全的
   1. 如果该对象没有逃离方法的作用范围，则他是线程安全的
   2. 反之则是非线程安全的

##### 局部变量线程安全分析

##### 常见的线程安全类

1. String
2. Integer
3. StringBuffer
4. Random
5. Vector
6. Hashtable
7. java.util.concurrent包下的类

这里说的线程安全指的是多个线程调用同一个实例的某一个方法时，是线程安全的

```java
Hashtable hashTable = new Hashtable();
new Thread(() -> hashTable.put("key", "value")).start();
new Thread(() -> hashTable.put("key", "value")).start();
```

**它们每个方法是原子的，但是它们的方法的组合就不是原子的**

如下方法不是线程安全的

```java
Hashtable hashTable = new Hashtable();
if(hashTable.get("key") == null) {
    hashTable.put("key", "value");
}
```

##### 不可变类线程安全性

String、Integer都是不可变类，其内部的状态都是不可变的，因此其方法都是线程安全的

#### 4.5习题

##### 买票练习

测试下面代码是否存在线程安全问题，如果有的话并进行修复

**模拟多人卖票**（sell方法加上 synchronized关键字以后是线程安全的）

```java
@Slf4j(topic = "ExerciseSell")
public class Test19ExerciseSell {

    // Random 是线程安全的
    private static Random random = new Random();

    public static void main(String[] args) throws InterruptedException {
        TicketWindow window = new TicketWindow(1000);

        List<Thread> threadList = new ArrayList<>();
        List<Integer> sellNumberList = new Vector<>();
        // 模拟多人买票
        for (int i = 0; i < 2000; i++) {
            Thread thread = new Thread(() -> {
                // 卖出去的票数
                int sellNumber = window.sell(randomAmount());
                sellNumberList.add(sellNumber);
            });
            thread.start();
            threadList.add(thread);
        }

        for (Thread thread : threadList) {
            thread.join();
        }

        // 卖出去的票总数
        int sellCount = sellNumberList.stream().mapToInt(item -> item).sum();
        log.info("卖出去的票总数:{}", sellCount);
        // 剩余票数量
        int surplusCount = window.getCount();
        log.info("剩余票数量:{}", surplusCount);

        log.info("卖出去的票总数 + 剩余票数量 :{}", sellCount + surplusCount);
    }

    /**
     * @return 生成随机数1-5
     */
    public static int randomAmount() {
        return random.nextInt(5) + 1;
    }
}

/**
 * 售票窗口
 */
class TicketWindow {

    private int count;

    public TicketWindow(int count) {
        this.count = count;
    }

    /**
     * @return 获取余票数量
     */
    public int getCount() {
        return this.count;
    }

    /**
     * 售票
     * @param amount 卖出去的票数
     * @return 卖出去的票数
     */
    public synchronized int sell(int amount) {
        if(this.count >= amount) {
            this.count -= amount;
            return amount;
        }else {
            return 0;
        }
    }
}
```

**转账场景模拟** （transfer方法加上synchronized关键字，锁住的是Account.class对象）

```java
@Slf4j(topic = "ExerciseTransfer")
public class Test20ExerciseTransfer {

    // Random 为线程安全
    private static Random random = new Random();

    public static void main(String[] args) throws InterruptedException {
        Account a = new Account(1000);
        Account b = new Account(1000);
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                a.transfer(b, randomAmount());
            }
        }, "t1");
        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                b.transfer(a, randomAmount());
            }
        }, "t2");
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        // 查看转账2000次后的总金额
        log.debug("total:{}",(a.getMoney() + b.getMoney()));
    }

    // 随机 1~100
    public static int randomAmount() {
        return random.nextInt(100) +1;
    }
}

class Account {
    private int money;
    public Account(int money) {
        this.money = money;
    }
    public int getMoney() {
        return money;
    }
    public void setMoney(int money) {
        this.money = money;
    }
    public void transfer(Account target, int amount) {
        synchronized (Account.class) {
            if (this.money > amount) {
                this.setMoney(this.getMoney() - amount);
                target.setMoney(target.getMoney() + amount);
            }
        }
    }
}
```

#### 4.6 Monitor概念

##### Java对象头

*以32位虚拟机为例*

1. 普通对象

   ```java
   |--------------------------------------------------------------|
   | Object Header (64 bits)                                      |
   |------------------------------------|-------------------------|
   | Mark Word (32 bits)                | Klass Word (32 bits)    |
   |------------------------------------|-------------------------|
   ```

2. 数组对象

   ```java
   |---------------------------------------------------------------------------------|
   |                                Object Header (96 bits)                          |
   |--------------------------------|-----------------------|------------------------|
   |              Mark Word(32bits) | Klass Word(32bits)    | array length(32bits)   |
   |--------------------------------|-----------------------|------------------------|
   ```

3. 其中mark work结构如为

   ```java
   |-------------------------------------------------------|--------------------|
   |                  Mark Word (32 bits)                  |      State         |
   |-------------------------------------------------------|--------------------|
   | hashcode:25 | age:4 | biased_lock:0         | 01      |      Normal        |
   |-------------------------------------------------------|--------------------|
   | thread:23 | epoch:2 | age:4 | biased_lock:1 | 01      |      Biased        |
   |-------------------------------------------------------|--------------------|
   | ptr_to_lock_record:30                       | 00      | Lightweight Locked |
   |-------------------------------------------------------|--------------------|
   | ptr_to_heavyweight_monitor:30               | 10      | Heavyweight Locked |
   |-------------------------------------------------------|--------------------|
   |                                             | 11      |  Marked for GC      |
   |-------------------------------------------------------|--------------------|
   ```

*64 位虚拟机 Mark Word*

```java
|--------------------------------------------------------------------|--------------------|
| Mark Word (64 bits)                                                | State              |  
|--------------------------------------------------------------------|--------------------|
| unused:25 | hashcode:31 | unused:1 | age:4 | biased_lock:0 | 01    | Normal             |
|--------------------------------------------------------------------|--------------------|
| thread:54 | epoch:2 | unused:1 | age:4 | biased_lock:1     | 01    | Biased             |
|--------------------------------------------------------------------|--------------------|
| ptr_to_lock_record:62                                      | 00    | Lightweight Locked |
|--------------------------------------------------------------------|--------------------|
| ptr_to_heavyweight_monitor:62                              | 10    | Heavyweight Locked |
|--------------------------------------------------------------------|--------------------|
|                                                            | 11    | Marked for GC      |
|--------------------------------------------------------------------|--------------------|
```

Monitor被称之为**监视器**或者**管程**，每个java对象都可以关联一个 monitor对象，如果使用synchronized给对象上锁（**重量级锁**）之后，

该对象头中的mark word就被设置为指向**monitor对象的指针**

**Monitor锁是由操作系统提供的，程序每次进入synchronized代码块都需要获取monitor锁，对程序的性能影响比较大**

**monitor结构如下**

<img src="D:\KUHAN Project\notes\doc\Java并发编程\imgs\monitor结构.png" alt="monitor结构" style="zoom:60%;" />

1. 刚开始monitor对象中的owner为null
2. 当thread2执行到synchronized(obj) 时，就会将monitor的owner设置为thread2（每一个monitor只能一个owner）
3. 当thread2在持有锁的过程中，如果thread3、thread4、thread5也来执行synchronized(obj)，就会进入EntryList阻塞队列中，处于BLOCKED阻塞状态
4. thread2执行完临界区中的代码完之后，开始唤醒EntryList阻塞队列中的线程来竞争锁，这个时候锁的竞争不一定是公平的（先进入阻塞队列中的线程不一定可以先竞争到锁）
5. 图中WaitSet集合中的thread0、thread1是之前获得过锁，但是条件不满足进入WAITING状态的线程，在后面的wait-notify章节中会讲到

**注意**

1. synchronized必须是进入同一个对象的monitor才会有上述效果
2. 不加synchronized的对象不会关联monitor监视器，不会有上述效果

##### 原理之synchronized

##### 锁升级故事（偏向锁、轻量级锁）

故事角色 

- 老王 - JVM 
- 小南 - 线程 
- 小女 - 线程 
- 房间 - 对象 
- 房间门上 - 防盗锁 - Monitor 
- 房间门上 - 小南书包 - 轻量级锁 
- 房间门上 - 刻上小南大名 - 偏向锁 
- 批量重刻名 - 一个类的偏向锁撤销到达 20 阈值 
- 不能刻名字 - 批量撤销该类对象的偏向锁，设置该类不可偏向

小南要使用房间保证计算不被其它人干扰（原子性），最初，他用的是防盗锁，当上下文切换时，锁住门。这样， 即使他离开了，别人也进不了门，他的工作就是安全的。

但是，很多情况下没人跟他来竞争房间的使用权。小女是要用房间，但使用的时间上是错开的，小南白天用，小女 晚上用。每次上锁太麻烦了，有没有更简单的办法呢？

小南和小女商量了一下，约定不锁门了，而是谁用房间，谁把自己的书包挂在门口，但他们的书包样式都一样，因 此每次进门前得翻翻书包，看课本是谁的，如果是自己的，那么就可以进门，这样省的上锁解锁了。万一书包不是 自己的，那么就在门外等，并通知对方下次用锁门的方式。

后来，小女回老家了，很长一段时间都不会用这个房间。小南每次还是挂书包，翻书包，虽然比锁门省事了，但仍 然觉得麻烦。

于是，小南干脆在门上刻上了自己的名字：【小南专属房间，其它人勿用】，下次来用房间时，只要名字还在，那 么说明没人打扰，还是可以安全地使用房间。如果这期间有其它人要用这个房间，那么由使用者将小南刻的名字擦 掉，升级为挂书包的方式。

同学们都放假回老家了，小南就膨胀了，在 20 个房间刻上了自己的名字，想进哪个进哪个。后来他自己放假回老 家了，这时小女回来了（她也要用这些房间），结果就是得一个个地擦掉小南刻的名字，升级为挂书包的方式。老 王觉得这成本有点高，提出了一种批量重刻名的方法，他让小女不用挂书包了，可以直接在门上刻上自己的名字

后来，刻名的现象越来越频繁，老王受不了了：算了，这些房间都不能刻名了，只能挂书包

##### 原理之synchronized进阶

##### 轻量级锁

1. 轻量级锁使用场景

   如果一个对象虽然有多个线程访问，但是多个线程的访问时间是错开的（也就是没有锁竞争），那么可以使用轻量级锁优化

   轻量级锁对使用者来说是透明的，语法上仍然使用的是synchronized

   **如果有锁竞争的话，轻量级锁会升级为重量级锁**

2. 代码实现

##### 锁膨胀

##### 自旋优化

##### 偏向锁

#### Wait&Notify原理

<img src="D:\KUHAN Project\notes\doc\Java并发编程\imgs\waiting和blocked状态.png" alt="waiting和blocked状态" style="zoom:60%;" />

1. owner线程发现条件不满足，调用wait方法**释放锁**，然后该线程进入WaitSet集合，状态切换为WAITING状态
2. BLOCKED状态和WAITING状态都是处于阻塞状态，都不占用时间片
3. BLOCKED状态的线程会在Owner线程释放锁时被唤醒
4. WAITING线程会在Ower线程调用`notify`或者`notifyAll`方法时被唤醒，但是唤醒之后并不意味着立刻持有锁，仍然需要进入EntrySet集合中和其他线程竞争

##### API介绍

1. obj.wait( )

   让进入object监视器中的线程，状态切换至WAITING状态，进入WaitSet集合进行等待

2. obj.notify( )

   在object上正在WaitSet等待的线程中挑选一个进行唤醒

3. obj.notifyAll( )

   唤醒所有的在object上WaitSet集合等待的线程

以上三个方法都属于**object对象上的方法**，通过他们可以实现线程之间**相互调度**。必须**获得对象上的锁**，才可以调用以上的三个方法。

```java
@Slf4j(topic = "Test21WaitNotify")
public class Test21WaitNotify {

    private final static Object LOCK = new Object();

    public static void main(String[] args) throws InterruptedException {

        new Thread(() -> {
            log.info("线程1执行...");
            synchronized (LOCK) {
                try {
                    LOCK.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            log.info("线程1唤醒之后执行的代码...");
        }, "T1").start();

        new Thread(() -> {
            log.info("线程2执行...");
            synchronized (LOCK) {
                try {
                    LOCK.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            log.info("线程2唤醒之后执行的代码...");
        }, "T2").start();


        // 主线程睡眠两秒
        TimeUnit.SECONDS.sleep(2);
        // 主线程睡眠两秒之后开始唤醒子线程
        log.info("主线程睡眠两秒之后随机唤醒子线程...");
        synchronized (LOCK) {
            // 随机唤醒一个子线程
            // LOCK.notify();
            // 唤醒所有WaitSet集合中的线程
            LOCK.notifyAll();
        }
    }
}
```

#### Wait&Notify的正确姿势

##### sleep (long n) & wait (long n) 区别

1. sleep是Thread的方法，wait 是Object的方法
2. sleep不需要强制和synchronized配合使用，但是wait必须和synchronized配合使用（只有持有锁的线程才可以调用wait方法，否则会抛异常）
3. sleep在睡眠过程中不会释放对象锁，wait方法在等待过程中会释放锁
4. 他们都是TIMED_WAITING状态

##### step1

**方案特点：**：线程在sleep睡眠时会一直持有锁

```java
@Slf4j(topic = "Test22CigaretteStep1")
public class Test22CigaretteStep1 {

    private static final Object room = new Object();
    private static boolean hasCigarette = false;
    private static boolean hasTakeout = false;

    public static void main(String[] args) {
        new Thread(() -> {
            synchronized (room) {
                log.debug("有烟没？[{}]", hasCigarette);
                if (!hasCigarette) {
                    log.debug("没烟，先歇会！");
                    try {
                        TimeUnit.SECONDS.sleep(2);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                log.debug("有烟没？[{}]", hasCigarette);
                if (hasCigarette) {
                    log.debug("可以开始干活了");
                }
            }
        }, "小南").start();

        for (int i = 0; i < 5; i++) {
            new Thread(() -> {
                synchronized (room) {
                    log.debug("可以开始干活了");
                }
            }, "其它人").start();
        }

        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        new Thread(() -> {
            // 这里能不能加 synchronized (room)？
            hasCigarette = true;
            log.debug("烟到了噢！");
        }, "送烟的").start();
    }
}
```

**该方案缺点：**

1. 小南线程在睡眠时其他干活的线程会处于阻塞状态，效率太低

2. 小南线程必须睡足两秒才能醒过来，就算烟提前送到，也不能立刻醒来

3. 送烟线程也加了 synchronized (room) 之后就好比小南在里面反锁了们睡觉，送烟线程根本无法将送进来（小南线程代码块运行结束以后才可以改变送烟状态，这时候再送烟已经毫无意义）

   送烟线程没有添加synchronized (room) 时，可以理解为时翻窗户进来送烟的（**非线程安全的**）

**优化方案**

使用wait - notify优化

##### step2

使用wait - notify优化

```java
@Slf4j(topic = "Test22CigaretteStep1")
public class Test22CigaretteStep2 {

    private static final Object room = new Object();
    private static boolean hasCigarette = false;
    private static boolean hasTakeout = false;

    public static void main(String[] args) {
        new Thread(() -> {
            synchronized (room) {
                log.debug("有烟没？[{}]", hasCigarette);
                if (!hasCigarette) {
                    log.debug("没烟，先歇会！");
                    try {
                        room.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                log.debug("有烟没？[{}]", hasCigarette);
                if (hasCigarette) {
                    log.debug("可以开始干活了");
                }
            }
        }, "小南").start();

        for (int i = 0; i < 5; i++) {
            new Thread(() -> {
                synchronized (room) {
                    log.debug("可以开始干活了");
                }
            }, "其它人").start();
        }

        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        new Thread(() -> {
            // 这里能不能加 synchronized (room)？
            synchronized (room) {
                hasCigarette = true;
                log.debug("烟到了噢！");
                room.notify();
            }
        }, "送烟的").start();
    }
}

17:15:26.362 [小南] DEBUG Test22CigaretteStep1 - 有烟没？[false]
17:15:26.365 [小南] DEBUG Test22CigaretteStep1 - 没烟，先歇会！
17:15:26.365 [其它人] DEBUG Test22CigaretteStep1 - 可以开始干活了
17:15:26.366 [其它人] DEBUG Test22CigaretteStep1 - 可以开始干活了
17:15:26.366 [其它人] DEBUG Test22CigaretteStep1 - 可以开始干活了
17:15:26.366 [其它人] DEBUG Test22CigaretteStep1 - 可以开始干活了
17:15:26.366 [其它人] DEBUG Test22CigaretteStep1 - 可以开始干活了
17:15:27.362 [送烟的] DEBUG Test22CigaretteStep1 - 烟到了噢！
17:15:27.362 [小南] DEBUG Test22CigaretteStep1 - 有烟没？[true]
17:15:27.362 [小南] DEBUG Test22CigaretteStep1 - 可以开始干活了
```

##### wait - notify方案评价

1. 解决其他可以干活线程阻塞问题（**优化性能**）
2. **如果有其他线程也在等待唤醒呢？可能导致错误唤醒其他线程**

##### step3

使用notifyAll唤醒所有处于wait状态的线程

```java
@Slf4j(topic = "Test22CigaretteStep1")
public class Test22CigaretteStep3 {

    private static final Object room = new Object();
    private static boolean hasCigarette = false;
    private static boolean hasTakeout = false;

    public static void main(String[] args) {
        new Thread(() -> {
            synchronized (room) {
                log.debug("有烟没？[{}]", hasCigarette);
                if (!hasCigarette) {
                    log.debug("没烟，先歇会！");
                    try {
                        room.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                log.debug("有烟没？[{}]", hasCigarette);
                if (hasCigarette) {
                    log.debug("可以开始干活了");
                } else {
                    log.debug("没干成活...");
                }
            }
        }, "小南").start();


        new Thread(() -> {
            synchronized (room) {
                log.debug("外卖送到没？[{}]", hasTakeout);
                if (!hasTakeout) {
                    log.debug("没外卖，先歇会！");
                    try {
                        room.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                log.debug("外卖送到没？[{}]", hasTakeout);
                if (hasTakeout) {
                    log.debug("可以开始干活了");
                } else {
                    log.debug("没干成活...");
                }
            }
        }, "小女").start();

        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        new Thread(() -> {
            synchronized (room) {
                hasTakeout = true;
                log.debug("外卖到了噢！");
                room.notifyAll();
            }
        }, "送外卖的").start();
    }
}
```

```java
17:25:13.747 [小南] DEBUG Test22CigaretteStep1 - 有烟没？[false]
17:25:13.750 [小南] DEBUG Test22CigaretteStep1 - 没烟，先歇会！
17:25:13.751 [小女] DEBUG Test22CigaretteStep1 - 外卖送到没？[false]
17:25:13.751 [小女] DEBUG Test22CigaretteStep1 - 没外卖，先歇会！
17:25:14.745 [送外卖的] DEBUG Test22CigaretteStep1 - 外卖到了噢！
17:25:14.745 [小南] DEBUG Test22CigaretteStep1 - 有烟没？[false]
17:25:14.745 [小南] DEBUG Test22CigaretteStep1 - 没干成活...
```

**step3方案评价**

1. 如果有多个处于等待状态的线程，那么这种方案可能会错误唤醒本来不应该被唤醒的线程，即**虚假唤醒**

##### step4 

使用**while循环**判断送烟/送饭状态，如果没有满足条件则工作线程直接**进入下一轮wait**

```java
@Slf4j(topic = "Test22CigaretteStep1")
public class Test22CigaretteStep3 {

    private static final Object room = new Object();
    private static boolean hasCigarette = false;
    private static boolean hasTakeout = false;

    public static void main(String[] args) {
        new Thread(() -> {
            synchronized (room) {
                log.debug("有烟没？[{}]", hasCigarette);
                while (!hasCigarette) {
                    log.debug("没烟，先歇会！");
                    try {
                        room.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                log.debug("有烟没？[{}]", hasCigarette);
                if (hasCigarette) {
                    log.debug("可以开始干活了");
                } else {
                    log.debug("没干成活...");
                }
            }
        }, "小南").start();


        new Thread(() -> {
            synchronized (room) {
                log.debug("外卖送到没？[{}]", hasTakeout);
                while (!hasTakeout) {
                    log.debug("没外卖，先歇会！");
                    try {
                        room.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                log.debug("外卖送到没？[{}]", hasTakeout);
                if (hasTakeout) {
                    log.debug("可以开始干活了");
                } else {
                    log.debug("没干成活...");
                }
            }
        }, "小女").start();

        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        new Thread(() -> {
            synchronized (room) {
                hasTakeout = true;
                log.debug("外卖到了噢！");
                room.notifyAll();
            }
        }, "送外卖的").start();
    }
}
```

```java
17:36:01.376 [小南] DEBUG Test22CigaretteStep1 - 有烟没？[false]
17:36:01.379 [小南] DEBUG Test22CigaretteStep1 - 没烟，先歇会！
17:36:01.380 [小女] DEBUG Test22CigaretteStep1 - 外卖送到没？[false]
17:36:01.380 [小女] DEBUG Test22CigaretteStep1 - 没外卖，先歇会！
17:36:02.375 [送外卖的] DEBUG Test22CigaretteStep1 - 外卖到了噢！
17:36:02.375 [小女] DEBUG Test22CigaretteStep1 - 外卖送到没？[true]
17:36:02.375 [小女] DEBUG Test22CigaretteStep1 - 可以开始干活了
17:36:02.376 [小南] DEBUG Test22CigaretteStep1 - 没烟，先歇会！
```

##### wait & notify的使用套路

```java
// 工作线程
synchronized (lock) {
    while (条件不成立) {
        lock.wait();
    }

    // TODO 做条件成立的事情
}

// 其他线程（处理工作线程的判断条件）
synchronized (lock) {
    // 处理工作线程的条件
    // 唤醒所有线程
    lock.notifyAll();
}
```

#### Join原理

#### Park&Unpark原理

##### 基本使用

他们是LockSupport类中的方法

```java
// 暂停当前线程
LockSupport.park()
    
// 恢复某个线程的运行
LockSupport.unpark(暂停的线程对象)    
```

**先park再unpark**

**处于park状态的线程本质上是处于WAIT状态的**

```java
@Slf4j(topic = "Test26Park")
public class Test26Park {
    public static void main(String[] args) {
        Thread thread = new Thread(() -> {
            log.info("start...");
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            log.info("park...");
            LockSupport.park();
            log.info("resume...");
        });
        thread.start();

        try {
            TimeUnit.SECONDS.sleep(2);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        log.info("unpark...");
        LockSupport.unpark(thread);
    }
}
```

```java
20:28:44.517 [Thread-0] INFO Test26Park - start...
20:28:45.520 [Thread-0] INFO Test26Park - park...
20:28:46.515 [main] INFO Test26Park - unpark...
20:28:46.515 [Thread-0] INFO Test26Park - resume...
```

**先unpark再park**

```java
@Slf4j(topic = "Test26Park")
public class Test26Park {
    public static void main(String[] args) {
        Thread thread = new Thread(() -> {
            log.info("start...");
            try {
                TimeUnit.SECONDS.sleep(2);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            log.info("park...");
            LockSupport.park();
            log.info("resume...");
        });
        thread.start();

        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        log.info("unpark...");
        LockSupport.unpark(thread);
    }
}
```

```java
20:38:27.604 [Thread-0] INFO Test26Park - start...
20:38:28.603 [main] INFO Test26Park - unpark...
20:38:29.608 [Thread-0] INFO Test26Park - park...
20:38:29.608 [Thread-0] INFO Test26Park - resume...
```

通过线程的执行时间可知`unpark`即可以在`park`之前，也可以在`park`之后调用

##### 特点

`park`和`unpark`与Object中的`wait`、`notify`、`notifyAll`方法相比较

1. wait、notify、notifyAll必须配合Object Monitor一起使用，然而unpark方法不用
2. `park`和`unpark`是以**线程为单位**【阻塞】或者【唤醒】线程的，然而notify只能随机唤醒一个等待的线程，notifyAll可以唤醒所有线程（容易造成虚假唤醒的状况），并不是那么的精确
3. `park`和`unpark`方法中可以先`unpark`，但是`wait`、`notify`不能先`notify`

##### 原理之park & unpark

<img src="https://cdn.jsdelivr.net/gh/Andre235/-community@master/park.5hlcmynf0900.png" alt="park" style="zoom: 67%;" />

每个线程都有自己的park对象，主要有三部分组成：_counter、_cond、_mutex

1. 线程就像一个旅人，parker就像他随身携带的旅行包，_cond条件变量就好比背包中的帐篷，_counter就好比背包中的备用干粮（0：耗尽、1：充足）

2. 调用park就是**判断**需不需要休息

   1. 如果备用干粮耗尽，则线程钻进帐篷休息
   2. 如果备用干粮充足，则不需要休息，继续执行

3. 调用unpark，就好比**使**备用干粮充足

   1. 如果这个时候线程在帐篷中，则叫醒他继续让他前行

   2. 如果这个时候线程在执行中，那么该线程下次被调用park时，仅仅是消耗掉之前的备用干粮，不需要停留，继续前进

      **因为背包的空间是有限的，多次调用unpark仅仅会补充一次备用干粮**

#### 重新理解线程的状态转换

<img src="https://cdn.jsdelivr.net/gh/Andre235/-community@master/重新理解线程状态.1w3h2pc2h4g0.png" alt="重新理解线程状态" style="zoom:67%;" />

假设有线程 Thread t

##### 情况1`NEW --> RUNNABLE`

当调用 t.start() 方法时，由 NEW --> RUNNABLE

##### 情况 2 `RUNNABLE <--> WAITING`

**t 线程**用 `synchronized(obj)` 获取了对象锁后

1. 调用 obj.wait() 方法时，t 线程从 RUNNABLE --> WAITING
2. 调用 obj.notify() ， obj.notifyAll() ， t.interrupt() 时
   1. 竞争锁成功，t 线程从 WAITING --> RUNNABLE
   2. 竞争锁失败，t 线程从 WAITING --> BLOCKED

```java
@Slf4j(topic = "c.TestWaitNotify")
public class Test27WaitNotify {
    final static Object obj = new Object();

    public static void main(String[] args) {

        new Thread(() -> {
            synchronized (obj) {
                log.debug("执行....");
                try {
                    obj.wait(); // 让线程在obj上一直等待下去
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                log.debug("其它代码....");
            }
        },"t1").start();

        new Thread(() -> {
            synchronized (obj) {
                log.debug("执行....");
                try {
                    obj.wait(); // 让线程在obj上一直等待下去
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                log.debug("其它代码....");
            }
        },"t2").start();

        // 主线程两秒后执行
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        log.debug("唤醒 obj 上其它线程");
        synchronized (obj) {
//            obj.notify(); // 唤醒obj上一个线程
            obj.notifyAll(); // 唤醒obj上所有等待线程
        }
    }
}
```

##### 情况 3 `RUNNABLE <--> WAITING`

1. 当前线程调用 t.join() 方法时，当前线程从 RUNNABLE --> WAITING

   注意是当前线程在t 线程对象的监视器上等待

2. t 线程运行结束，或调用了当前线程的 interrupt() 时，当前线程从 WAITING --> RUNNABLE

##### 情况 4 `RUNNABLE <--> WAITING`

1. 当前线程调用 LockSupport.park() 方法会让当前线程从 RUNNABLE --> WAITING
2. 调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，会让目标线程从 WAITING --> RUNNABLE

##### 情况 5 `RUNNABLE <--> TIMED_WAITING`

t 线程用 synchronized(obj) 获取了对象锁后

1. 调用 obj.wait(long n) 方法时，t 线程从 RUNNABLE --> TIMED_WAITING
2. t 线程等待时间超过了 n 毫秒，或调用 obj.notify() ， obj.notifyAll() ， t.interrupt() 时
   1. 竞争锁成功，t 线程从 TIMED_WAITING --> RUNNABLE
   2. 竞争锁失败，t 线程从 TIMED_WAITING --> BLOCKED

##### 情况 6 `RUNNABLE <--> TIMED_WAITING`

1. 当前线程调用 t.join(long n) 方法时，当前线程从 RUNNABLE --> TIMED_WAITING

   注意是当前线程在t 线程对象的监视器上等待

2. 当前线程等待时间超过了 n 毫秒，或t 线程运行结束，或调用了当前线程的 interrupt() 时，当前线程从 TIMED_WAITING --> RUNNABLE

##### 情况 7 `RUNNABLE <--> TIMED_WAITING`

1. 当前线程调用 Thread.sleep(long n) ，当前线程从 RUNNABLE --> TIMED_WAITING
2. 当前线程睡眠时间超过了 n 毫秒，当前线程从 TIMED_WAITING --> RUNNABLE

##### 情况 8 `RUNNABLE <--> TIMED_WAITING`

1. 当前线程调用 LockSupport.parkNanos(long nanos) 或 LockSupport.parkUntil(long millis) 时，当前线 程从 RUNNABLE --> TIMED_WAITING
2. 调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，或是等待超时，会让目标线程从 TIMED_WAITING--> RUNNABLE

##### 情况 9 `RUNNABLE <--> BLOCKED`

1. t 线程用 synchronized(obj) 获取了对象锁时如果竞争失败，从 RUNNABLE --> BLOCKED
2. 持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 BLOCKED 的线程重新竞争，如果其中 t 线程竞争 成功，从 BLOCKED --> RUNNABLE ，其它失败的线程仍然 BLOCKED

##### 情况 10 `RUNNABLE <--> TERMINATED`

当前线程所有代码运行完毕，进入 TERMINATED

#### 多把锁

**多把不相干的锁**

一个大屋子可以两个功能：**睡觉功能**、**学习功能**，这两个功能是没有关系的

现在小南想要学习，小女想要睡觉，但是只能用一件屋子的话（只能有一个对象锁），并发度是很低的

##### 粗粒度锁

```java
@Slf4j(topic = "BigRoom")
public class Test28BigRoom {
    public static void main(String[] args) throws InterruptedException {
        log.info("主线程开始执行....");
        BigRoom bigRoom = new BigRoom();
        Thread thread1 = new Thread(bigRoom::study, "小南");
        Thread thread2 = new Thread(bigRoom::sleep, "小女");
        thread1.start();
        thread2.start();
        thread1.join();
        thread2.join();
        log.info("主线程执行结束....");
    }
}

@Slf4j(topic = "BigRoom")
class BigRoom {
    public void sleep() {
        synchronized (this) {
            log.debug("sleeping 2 小时");
            try {
                TimeUnit.SECONDS.sleep(2);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
    public void study() {
        synchronized (this) {
            log.debug("study 1 小时");
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

```

```java
09:40:09.201 [main] INFO BigRoom - 主线程开始执行....
09:40:09.240 [小南] DEBUG BigRoom - study 1 小时
09:40:10.240 [小女] DEBUG BigRoom - sleeping 2 小时
09:40:12.242 [main] INFO BigRoom - 主线程执行结束....
```

##### 细粒度锁

```java
@Slf4j(topic = "BigRoom")
public class Test29BigRoom {
    public static void main(String[] args) throws InterruptedException {
        log.info("主线程开始执行....");
        TestRoom bigRoom = new TestRoom();
        Thread thread1 = new Thread(bigRoom::study, "小南");
        Thread thread2 = new Thread(bigRoom::sleep, "小女");
        thread1.start();
        thread2.start();
        thread1.join();
        thread2.join();
        log.info("主线程执行结束....");
    }
}

@Slf4j(topic = "BigRoom")
class TestRoom {

    private final Object studyLock = new Object();
    private final Object sleepLock = new Object();

    public void sleep() {
        synchronized (sleepLock) {
            log.debug("sleeping 2 小时");
            try {
                TimeUnit.SECONDS.sleep(2);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
    public void study() {
        synchronized (studyLock) {
            log.debug("study 1 小时");
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

```java
09:48:57.487 [main] INFO BigRoom - 主线程开始执行....
09:48:57.528 [小南] DEBUG BigRoom - study 1 小时
09:48:57.528 [小女] DEBUG BigRoom - sleeping 2 小时
09:48:59.529 [main] INFO BigRoom - 主线程执行结束...
```

将锁的粒度细分

1. 好处：可以增强并发度
2. 坏处：如果一个线程同事需要获得多把锁，很容易产生死锁

#### 活跃性

##### 死锁

产生死锁的原因：一个线程需要同时获得多把锁，这个时候就容易造成死锁（多个线程各自都持有一把锁，还想获取对方线程的锁）

`T1线程`获得`A对象的锁`之后，接下来想获得`B对象的锁`

`T2线程`获得`B对象`的锁之后，接下来想获得`A对象的锁`

*最终彼此的代码都无法往下执行*

##### 定位死锁

##### `jps`查看Java进程信息

```java
D:\KUHAN Project\ops-monitor-backend>jps
16340 Test30DeadLock
4052 Jps
7912
2172 Launcher
```

##### `jstack`查看线程中的进程信息

```java
D:\KUHAN Project\ops-monitor-backend>jstack 4084

Found one Java-level deadlock:
=============================
"T2":
  waiting to lock monitor 0x000000001feb99c8 (object 0x000000076d2165c8, a java.lang.Object),
  which is held by "T1"
"T1":
  waiting to lock monitor 0x000000001c625598 (object 0x000000076d2165d8, a java.lang.Object),
  which is held by "T2"

Java stack information for the threads listed above:
===================================================
"T2":
        at com.kuhan.ops.monitor.system.Test30DeadLock.lambda$main$1(Test30DeadLock.java:41)
        - waiting to lock <0x000000076d2165c8> (a java.lang.Object)
        - locked <0x000000076d2165d8> (a java.lang.Object)
        at com.kuhan.ops.monitor.system.Test30DeadLock$$Lambda$2/1123629720.run(Unknown Source)
        at java.lang.Thread.run(Thread.java:748)
"T1":
        at com.kuhan.ops.monitor.system.Test30DeadLock.lambda$main$0(Test30DeadLock.java:27)
        - waiting to lock <0x000000076d2165d8> (a java.lang.Object)
        - locked <0x000000076d2165c8> (a java.lang.Object)
        at com.kuhan.ops.monitor.system.Test30DeadLock$$Lambda$1/445288316.run(Unknown Source)
        at java.lang.Thread.run(Thread.java:748)

Found 1 deadlock.
```

`jconsole控制台`查看线程信息

##### <img src="https://cdn.jsdelivr.net/gh/Andre235/-community@master/jconsole.2qnplkpancy0.png" alt="jconsole" style="zoom:67%;" />哲学家就餐问题

<img src="https://cdn.jsdelivr.net/gh/Andre235/-community@master/哲学及就餐问题.62wkz0i6leg0.png" alt="哲学及就餐问题" style="zoom: 67%;" />

有五位哲学家，围坐在圆桌旁准备吃饭

1. 他们只做两件事情：吃饭和思考，思考一会吃会饭，吃饭完之后接着思考
2. 吃饭时要用两根筷子，但是桌子上只有五根筷子（每个哲学家左手右手边各有一根筷子）
3. 如果其中的一根筷子被身边的人拿着，自己就需要等着

筷子类

```java
class Chopstick {
    private String name;

    public Chopstick(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "Chopstick{" +
                "name='" + name + '\'' +
                '}';
    }
}
```

哲学家类

```java
@Slf4j(topic = "Philosopher")
class Philosopher extends Thread {
    private Chopstick left;
    private Chopstick right;

    public Philosopher(String name, Chopstick left, Chopstick right) {
        super(name);
        this.left = left;
        this.right = right;
    }

    private void eat() {
        log.info("eat...");
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    /**
     * 吃饭
     */
    @Override
    public void run() {
        while (true) {
            // 获得左手筷子
            synchronized (left) {
                // 获得右手筷子
                synchronized (right) {
                    // 获取两把锁之后开始吃饭
                    eat();
                }
                // 放下右手筷子
            }
            // 放下左手筷子
        }
    }
}
```

主线程

```java
public class Test31PhilosopherEat {
    public static void main(String[] args) {
        Chopstick c1 = new Chopstick("1");
        Chopstick c2 = new Chopstick("2");
        Chopstick c3 = new Chopstick("3");
        Chopstick c4 = new Chopstick("4");
        Chopstick c5 = new Chopstick("5");
        new Philosopher("苏格拉底", c1, c2).start();
        new Philosopher("柏拉图", c2, c3).start();
        new Philosopher("亚里士多德", c3, c4).start();
        new Philosopher("赫拉克利特", c4, c5).start();
        new Philosopher("阿基米德", c5, c1).start();
    }
}
```

输出日志

```java
11:23:26.587 [亚里士多德] INFO Philosopher - eat...
11:23:26.587 [苏格拉底] INFO Philosopher - eat...
11:23:27.590 [亚里士多德] INFO Philosopher - eat...
11:23:27.590 [苏格拉底] INFO Philosopher - eat...
11:23:28.591 [亚里士多德] INFO Philosopher - eat...
11:23:28.591 [苏格拉底] INFO Philosopher - eat...
11:23:29.591 [亚里士多德] INFO Philosopher - eat...
11:23:29.591 [阿基米德] INFO Philosopher - eat...
11:23:30.591 [阿基米德] INFO Philosopher - eat...
11:23:30.591 [亚里士多德] INFO Philosopher - eat...
11:23:31.591 [亚里士多德] INFO Philosopher - eat...
11:23:31.591 [阿基米德] INFO Philosopher - eat...
11:23:32.592 [阿基米德] INFO Philosopher - eat...
11:23:32.592 [亚里士多德] INFO Philosopher - eat...
11:23:33.592 [亚里士多德] INFO Philosopher - eat...
11:23:33.592 [阿基米德] INFO Philosopher - eat...
11:23:34.593 [亚里士多德] INFO Philosopher - eat...
11:23:35.593 [亚里士多德] INFO Philosopher - eat...
11:23:36.593 [亚里士多德] INFO Philosopher - eat...
11:23:37.593 [亚里士多德] INFO Philosopher - eat...
```

`jstack`查看死锁分析日志

```java
Found one Java-level deadlock:
=============================
"阿基米德":
  waiting to lock monitor 0x000000001fa79f58 (object 0x000000076cb31208, a com.kuhan.ops.monitor.system.Chopstick)
,
  which is held by "苏格拉底"
"苏格拉底":
  waiting to lock monitor 0x000000001c305318 (object 0x000000076cb31248, a com.kuhan.ops.monitor.system.Chopstick)
,
  which is held by "柏拉图"
"柏拉图":
  waiting to lock monitor 0x000000001c305268 (object 0x000000076cb31288, a com.kuhan.ops.monitor.system.Chopstick)
,
  which is held by "亚里士多德"
"亚里士多德":
  waiting to lock monitor 0x000000001c305478 (object 0x000000076cb312c8, a com.kuhan.ops.monitor.system.Chopstick)
,
  which is held by "赫拉克利特"
"赫拉克利特":
  waiting to lock monitor 0x000000001fa7cd68 (object 0x000000076cb31308, a com.kuhan.ops.monitor.system.Chopstick)
,
  which is held by "阿基米德"

Java stack information for the threads listed above:
===================================================
"阿基米德":
        at com.kuhan.ops.monitor.system.Philosopher.run(Test31PhilosopherEat.java:59)
        - waiting to lock <0x000000076cb31208> (a com.kuhan.ops.monitor.system.Chopstick)
        - locked <0x000000076cb31308> (a com.kuhan.ops.monitor.system.Chopstick)
"苏格拉底":
        at com.kuhan.ops.monitor.system.Philosopher.run(Test31PhilosopherEat.java:59)
        - waiting to lock <0x000000076cb31248> (a com.kuhan.ops.monitor.system.Chopstick)
        - locked <0x000000076cb31208> (a com.kuhan.ops.monitor.system.Chopstick)
"柏拉图":
        at com.kuhan.ops.monitor.system.Philosopher.run(Test31PhilosopherEat.java:59)
        - waiting to lock <0x000000076cb31288> (a com.kuhan.ops.monitor.system.Chopstick)
        - locked <0x000000076cb31248> (a com.kuhan.ops.monitor.system.Chopstick)
"亚里士多德":
        at com.kuhan.ops.monitor.system.Philosopher.run(Test31PhilosopherEat.java:59)
        - waiting to lock <0x000000076cb312c8> (a com.kuhan.ops.monitor.system.Chopstick)
        - locked <0x000000076cb31288> (a com.kuhan.ops.monitor.system.Chopstick)
"赫拉克利特":
        at com.kuhan.ops.monitor.system.Philosopher.run(Test31PhilosopherEat.java:59)
        - waiting to lock <0x000000076cb31308> (a com.kuhan.ops.monitor.system.Chopstick)
        - locked <0x000000076cb312c8> (a com.kuhan.ops.monitor.system.Chopstick)

Found 1 deadlock.

```

**如何解决哲学家就餐问题：使用ReentrentLock可重入锁可以实现**

##### 活锁

1. 活锁出现场景

   两个线程互相改变对方的结束条件，导致最后谁也无法结束运行

2. 活锁代码实现

   ```java
   @Slf4j(topic = "Test32LiveLock")
   public class Test32LiveLock {
       private static int counter = 10;
   
       public static void main(String[] args) {
           new Thread(() -> {
               while (counter > 0) {
                   counter --;
                   log.info("counter: {}", counter);
                   try {
                       TimeUnit.MILLISECONDS.sleep(500);
                   } catch (InterruptedException e) {
                       e.printStackTrace();
                   }
               }
           }).start();
           new Thread(() -> {
               while (counter < 20) {
                   counter ++;
                   log.info("counter: {}", counter);
                   try {
                       TimeUnit.MILLISECONDS.sleep(500);
                   } catch (InterruptedException e) {
                       e.printStackTrace();
                   }
               }
           }).start();
       }
   }
   ```

3. 如何避免活锁

   给线程增加随机的睡眠时间

##### 饥饿

很多教程把饥饿定义为，一个线程的优先级太低， 始终得不到CPU调度执行，也不能够结束执行

饥饿情况不易演示，讲解读写锁是会涉及到饥饿问题

1. 下面演示的是使用**非顺序加锁**导致死锁的例子

   非顺序加锁：线程1获取锁A，线程2获取锁B；接下来线程1尝试获取锁B，线程2尝试获取锁A。这种非顺序加锁的方式会导致死锁的情况发生

   <img src="https://cdn.jsdelivr.net/gh/Andre235/-community@master/死锁线程模拟.719hjntsf0s0.png" alt="死锁线程模拟" style="zoom:67%;" />

2. 下面演示的是采用顺序加锁的方式解决死锁的案例，但是同时会带来**线程饥饿**的问题

   顺序加锁：线程1尝试获取锁A（成功），线程1再次尝试获取锁B（成功）；线程2尝试获取锁A（阻塞），线程2再次尝试获取锁B（阻塞）

   <img src="https://cdn.jsdelivr.net/gh/Andre235/-community@master/顺序加锁情况.134ch98gf3z4.png" alt="顺序加锁情况" style="zoom:67%;" />

#### ReentrantLock

相对于synchronized，它具备如下特点：

1. 可中断

2. 可以设置超时时间

   规定时间内，如果获取不到锁，那么放弃竞争锁

3. 可以设置为公平锁

   大家排队等待CPU时间片，则先到先得

4. 可以支持多个条件变量

   支持多个WaitSet，不满足条件1的线程在WaitSet1集合里面等待，不满足条件2的线程在WaitSet2集合里面等待

5. 与synchronized一样，都可以支持锁重入

   对同一个对象，可以反复加锁

##### 基本用法

```java
// 加锁
reentrantLock.lock();
try {
    // 临界区代码
} finally {
    // 释放锁
    reentrantLock.unlock();
}
```

##### 可重入锁

可重入就是一个线程如果首次获取了这把锁，那么他就是这把锁的拥有者，因此有权利再次获得这把锁

如果是不可重入锁，那么第二次再次获得这把锁时，自己也会被这把锁挡住

```java
@Slf4j(topic = "ReentrantLock")
public class Test33ReentrantLock {

    private final static ReentrantLock lock = new ReentrantLock();

    public static void main(String[] args) {
        lock.lock();
        try {
            log.info("execute main function...");
            fun1();
        } finally {
            lock.unlock();
        }
    }

    private static void fun1() {
        lock.lock();
        try {
            log.info("execute fun1 function...");
            fun2();
        } finally {
            lock.unlock();
        }
    }

    private static void fun2() {
        lock.lock();
        try {
            log.info("execute fun2 function...");
        } finally {
            lock.unlock();
        }
    }
}
```

##### 可打断锁

1. 定义

   没有线程1没有竞争，此方法就会获取lock对象锁； 如果有竞争则线程1进入阻塞队列，同时可以被其他线程用interrupt方法去打断阻塞状态

2. 应用场景

   可打断锁在被打断以后，线程直接运行结束(防止线程无限制地阻塞等待下去)

3. 代码实现

   ```java
   @Slf4j(topic = "InterruptLock")
   public class Test33InterruptLock {
   
       private final static ReentrantLock lock = new ReentrantLock();
   
       public static void main(String[] args) throws InterruptedException {
           Thread thread = new Thread(() -> {
               try {
                   log.info("尝试获得锁");
                   // 一个可以被打断的锁
                   // 如果没有竞争，此方法就会获取lock对象锁
                   // 如果有竞争则进入阻塞队列，同时可以被其他线程用interrupt方法去打断阻塞状态，该线程执行结束(反之线程无限制地等待下去)
                   lock.lockInterruptibly();
               } catch (InterruptedException e) {
                   log.error("没有获得锁，被其他线程打断，返回");
                   e.printStackTrace();
                   return;
               }
   
               try {
                   log.info("获取到锁");
               } finally {
                   lock.unlock();
               }
   
           }, "T1");
   
           // 主线程先加锁，T1线程这个时候会阻塞住
           lock.lock();
           thread.start();
   
           TimeUnit.SECONDS.sleep(1);
           log.info("主线程打断T1线程，程序运行结束...");
           thread.interrupt();
       }
   }
   ```

   ##### 锁超时

   1. 超时锁定义

      在给定的时间范围内尝试获取锁，**获取不到则线程运行结束**

   2. 思想

      避免线程无限制地获取锁，**防止线程死锁**

   3. 代码实现

      ```java
      @Slf4j(topic = "TryLock")
      public class Test34TryLock {
          private final static ReentrantLock lock = new ReentrantLock();
      
          public static void main(String[] args) {
              Thread thread = new Thread(() -> {
                  // 尝试获取锁
                  try {
                      if(!lock.tryLock(3, TimeUnit.SECONDS)) {
                          log.info("尝试获取锁失败，线程运行结束...");
                          return;
                      }
                  } catch (InterruptedException e) {
                      e.printStackTrace();
                      log.info("尝试获取锁失败，线程运行结束...");
                      return;
                  }
                  try{
                      log.info("获取到锁，执行临界区代码...");
                  } finally {
                      lock.unlock();
                  }
              });
              log.info("主线程获取锁....");
              lock.lock();
              thread.start();
          }
      }
      ```

   4. 解决哲学家就餐问题

      核心代码

      ```java
      class Chopstick1 extends ReentrantLock {
          private String name;
      
          public Chopstick1(String name) {
              this.name = name;
          }
      
          @Override
          public String toString() {
              return "Chopstick{" +
                      "name='" + name + '\'' +
                      '}';
          }
      }
      ```

      ```java
          /**
           * 吃饭
           */
          @Override
          public void run() {
              while (true) {
                  // 获得左手筷子
                  if (left.tryLock()) {
                      try {
                          // 获得右手筷子
                          if (right.tryLock()) {
                              try {
                                  eat();
                              } finally {
                                  right.unlock();
                              }
                          }
                      } finally {
                          // 如果右手筷子获取失败，则会放弃现在手中的左手筷子
                          left.unlock();
                      }
                  }
              }
          }
      ```

      所有代码

      ```java
      public class Test35PhilosopherEat {
          public static void main(String[] args) {
              Chopstick1 c1 = new Chopstick1("1");
              Chopstick1 c2 = new Chopstick1("2");
              Chopstick1 c3 = new Chopstick1("3");
              Chopstick1 c4 = new Chopstick1("4");
              Chopstick1 c5 = new Chopstick1("5");
              new Philosopher1("苏格拉底", c1, c2).start();
              new Philosopher1("柏拉图", c2, c3).start();
              new Philosopher1("亚里士多德", c3, c4).start();
              new Philosopher1("赫拉克利特", c4, c5).start();
              new Philosopher1("阿基米德", c5, c1).start();
          }
      }
      
      
      @Slf4j(topic = "Philosopher")
      class Philosopher1 extends Thread {
          private Chopstick1 left;
          private Chopstick1 right;
      
          public Philosopher1(String name, Chopstick1 left, Chopstick1 right) {
              super(name);
              this.left = left;
              this.right = right;
          }
      
          private void eat() {
              log.info("eat...");
              try {
                  TimeUnit.SECONDS.sleep(1);
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }
          }
      
          /**
           * 吃饭
           */
          @Override
          public void run() {
              while (true) {
                  // 获得左手筷子
                  if (left.tryLock()) {
                      try {
                          // 获得右手筷子
                          if (right.tryLock()) {
                              try {
                                  eat();
                              } finally {
                                  right.unlock();
                              }
                          }
                      } finally {
                          // 如果右手筷子获取失败，则会放弃现在手中的左手筷子
                          left.unlock();
                      }
                  }
              }
          }
      }
      
      
      class Chopstick1 extends ReentrantLock {
          private String name;
      
          public Chopstick1(String name) {
              this.name = name;
          }
      
          @Override
          public String toString() {
              return "Chopstick{" +
                      "name='" + name + '\'' +
                      '}';
          }
      }
      ```

   ##### 公平锁

   ReentrantLock 默认是不公平的

   ##### 条件变量

   1. synchronized条件变和ReentrantLock 的条件变量区别

      ReentrantLock 的条件变量相比较于synchronized条件变量最大的区别在于，**它支持多个条件变量**。可以理解为synchronized中那些条件不满足的线程都在一个休息室休息；然而ReentrantLock 支持多间休息室，有专门的等烟休息室，专门的等外卖的休息室。在唤醒线程的时候也是按照**休息室为单位**进行唤醒的

   2. ReentrantLock 的条件变量使用方法

      1. 在使用await方法之前需要先获得锁
      2. await方法执行之后会释放锁，进入Condition休息室等待
      3. await线程被唤醒/打断/超时会重新竞争lock锁
      4. 竞争lock锁成功之后，会从await之后继续执行

   3. 条件变量使用场景

      **使用await、signal方法可以实现多个线程之间的调度**

   4. 代码实现
      a
      ```java
      @Slf4j(topic = "AwaitSignal")
      public class Test36AwaitSignal {
      
          private static ReentrantLock lock = new ReentrantLock();
          private static Condition cigaretteWaitSet = lock.newCondition();
          private static Condition takeoutWaitSet = lock.newCondition();
          private static boolean hasCigarette = false;
          private static boolean hasTakeout = false;
      
          public static void main(String[] args) throws InterruptedException {
              new Thread(() -> {
                  lock.lock();
                  try {
                      log.info("烟送到没有:{}", hasCigarette);
                      while (!hasCigarette) {
                          log.info("没有烟，休息一下");
                          cigaretteWaitSet.await();
                      }
                      log.info("等到烟了，开始工作");
                  } catch (Exception e) {
                      e.printStackTrace();
                  } finally {
                      lock.unlock();
                  }
              }, "小南").start();
      
              new Thread(() -> {
                  lock.lock();
                  try {
                      log.info("外卖送到没有:{}", hasTakeout);
                      while (!hasTakeout) {
                          log.info("没有外卖，休息一下");
                          takeoutWaitSet.await();
                      }
                      log.info("等到外卖了，开始工作");
                  } catch (InterruptedException e) {
                      e.printStackTrace();
                  } finally {
                      lock.unlock();
                  }
              }, "小女").start();
      
              TimeUnit.SECONDS.sleep(1);
              new Thread(() -> {
                  lock.lock();
                  try {
                      log.info("烟送到了...");
                      hasCigarette = true;
                      cigaretteWaitSet.signal();
                  } finally {
                      lock.unlock();
                  }
              }, "送烟的").start();
      
              TimeUnit.SECONDS.sleep(1);
              new Thread(() -> {
                  lock.lock();
                  try {
                      log.info("外卖送到了...");
                      hasTakeout = true;
                      takeoutWaitSet.signal();
                  } finally {
                      lock.unlock();
                  }
              }, "送外卖的").start();
          }
      }
      ```

      ```java
      11:07:51.277 [小南] INFO AwaitSignal - 烟送到没有:false
      11:07:51.282 [小南] INFO AwaitSignal - 没有烟，休息一下
      11:07:51.282 [小女] INFO AwaitSignal - 外卖送到没有:false
      11:07:51.282 [小女] INFO AwaitSignal - 没有外卖，休息一下
      11:07:52.276 [送烟的] INFO AwaitSignal - 烟送到了...
      11:07:52.276 [小南] INFO AwaitSignal - 等到烟了，开始工作
      11:07:53.278 [送外卖的] INFO AwaitSignal - 外卖送到了...
      11:07:53.278 [小女] INFO AwaitSignal - 等到外卖了，开始工作
      ```


   ##### 同步模式之顺序控制

   #### 本章小节

   1. 分析多线程访问共享资源时，哪些代码属于临界区代码（既有读操作、又有写操作）。

      多线程操作临界区代码会出现线程安全问题，这个时候可以用synchronized或者reentrantLock机制保证线程安全问题

   2. 使用synchronized互斥机制解决临界区代码线程安全问题

      > synchronized获得不到锁，则就会一直进入等待阻塞状态

      1. 掌握synchronized锁对象的语法

      2. 掌握synchronized加在成员方法上、静态方法上语法

         加在成员方法上锁的是this对象

         加在静态方法锁的是Object.class类对象

      3. 掌握wait/notify同步方法

         **互斥**保障的是同一时刻只能有一个线程操作临界区代码，保证的是临界区代码的原子性（不会因为上下文切换出现线程安全问题）

         **同步**机制：某一个条件不满足时，线程1进入等待阻塞状态，直到条件满足（其他线程改变了线程1的运行条件）则继续向下运行

   3. 使用reentrantLock工具解决临界区线程安全问题

      > 相比较于synchronized，功能更加强大

      1. 可打断

         在获取不到锁时会进入等待阻塞状态，这个时候可以等待状态可以被打断，不会死等

      2. 锁超时

         在规定的使劲范围内如果获取不到锁，则线程运行结束，不会出现死等的情况

      3. 公平锁

         reentrantLock支持公平锁、非公平锁的支持

      4. 条件变量

         reentrantLock相比较于synchronized可有多个条件变量，可以使指定的线程进入不同的休息室，在唤醒线程时也是以条件变量为粒度进行唤醒的

   4. 了解线程活跃性问题

      死锁、活锁、饥饿

   5. 应用方面

      1. 互斥：使用synchronized或者reentrantLock可以达到共享资源的互斥效果
      2. 同步：使用wait/nofity或者lock的条件变量来达到线程之间调度效果

   6. 原理方面

      1. monitor、synchronized、wait/notify 原理
      2. synchronized进阶原理（锁升级过程）
      3. park & unpark 原理

   7. 模式方面

      1. 同步模式之保护性暂停

         **两个线程之间传递结果**

      2. 同步模式是生产者消费者

         多个线程之间结果的获取（不是一一对应关系）

      3. 同步模式之控制线程执行顺序

         1. 固定顺序执行
         2. 多个线程交替执行

      
