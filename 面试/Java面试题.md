### 微服务、分布式

##### Spring Cloud 和dubbo区别

1. 服务调用方式 dubbo是RPC springcloud Rest Api
2. 注册中心,dubbo 是zookeeper springcloud是eureka，也可以是zookeeper
3. 服务网关,dubbo本身没有实现，只能通过其他第三方技术整合，springcloud有Zuul路由网关，作为路由服务器，进行消费者的请求分发,springcloud支持断路器，与git完美集成配置文件支持版本控制，事物总线实现配置文件的更新与服务自动装配等等一系列的微服务架构要素。

##### 负载平衡的意义什么

在计算中，负载平衡可以改善跨计算机，计算机集群，网络链接，中央处理单元或磁盘驱动器等多种计算资源的工作负载分布。负载平衡旨在优化资源使用，最大化吞吐量，最小化响应时间并避免任何单一资源的过载。使用多个组件进行负载平衡而不是单个组件可能会通过冗余来提高可靠性和可用性。

1. 硬件层面进行负载均衡

   多层交换机或域名系统服务器进程

   硬件负载均衡解决方案是直接在服务器和外部网络间安装负载均衡设备，这种设备我们通常称之为负载均衡器。由于使用专门的设备完成网络请求转发的任务，独立于操作系统，整体性能高，负载均衡策略多样化，流量管理智能化。

2. 软件层面进行负载均衡

   Nginx/LVS/HAProxy是目前使用最广泛的三种开源的负载均衡软件。

   1. LVS

      LVS的是Linux Virtual Server的简写，翻译为Linux虚拟服务器，即一个虚拟的服务器集群系统

      LVS工作模式有4种：nat 地址转换、dr 直接路由、tun 隧道、full-nat

   2. NGINX

      Nginx是一款轻量级的Web服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，在BSD-like 协议下发行。其特点是占有内存少，并发能力强。Nginx默认采用多进程工作方式，Nginx启动后，会运行一个master进程和多个worker进程。

   3. HAProxy

      HAProxy是一个使用C语言编写的自由及开放源代码软件，它提供高可用性、负载均衡，以及基于TCP(第四层)和HTTP（第七层）的应用程序代理。HAProxy特别适用于那些负载特大的web站点，这些站点通常又需要会话保持或七层处理。

##### Eureka&ZooKeeper

1. ZooKeeper中的节点服务挂了就要选举 在选举期间注册服务瘫痪,虽然服务最终会恢复,但是选举期间不可用的， 选举就是改微服务做了集群，必须有一台主其他的都是从
2. Eureka各个节点是平等关系,服务器挂了没关系，只要有一台Eureka就可以保证服务可用，数据都是最新的。 如果查询到的数据并不是最新的，就是因为Eureka的自我保护模式导致的
3. Eureka可以很好的应对因网络故障导致部分节点失去联系的情况,而不会像ZooKeeper 一样使得整个注册系统瘫痪
4. ZooKeeper保证的是CP，Eureka保证的是AP

##### 网关

1. 网关作用

   统一管理微服务请求，权限控制、负载均衡、路由转发、监控、安全控制黑名单和白名单等

2. 常用的网关框架有哪些

   Nginx、Zuul、Gateway

##### Nginx与Ribbon的区别

Nginx是反向代理同时可以实现负载均衡，nginx拦截客户端请求采用负载均衡策略根据upstream配置进行转发，相当于请求通过nginx服务器进行转发。Ribbon是客户端负载均衡，从注册中心读取目标服务器信息，然后客户端采用轮询策略对服务直接访问，全程在客户端操作。

##### Ribbon底层实现原理

Ribbon使用discoveryClient从注册中心读取目标服务信息，对同一接口请求进行计数，使用%取余算法获取目标服务集群索引，返回获取到的目标服务信息。

##### [负载均衡算法](https://zhuanlan.zhihu.com/p/68733507)

1. 轮询法
2. 随机法
3. 源地址哈希法
4. 加权轮询法
5. 加权随机法
6. 最小连接数法

> 你在项目中用到的是那种负载均衡算法?为什么选用这种算法？

##### 分布式场景中如何保证数据的一致性？

##### 分布式场景中主键生成策略？

##### 分布式锁解决方案？

### Java虚拟机

##### JVM内存模型

##### JVM中一次完整的GC流程

> jvm中一次完整的GC流程（从ygc到fgc）是怎样的，重点讲讲对象如何晋升到老年代，几种主要的jvm参数等

##### 垃圾收集器

> 你知道哪几种垃圾收集器，各自的优缺点，重点讲下CMS和G1

##### JVM常用参数

### 消息队列

##### 消息队列架构

##### 消息处理过程

##### 各大MQ区别

> Kafka RabbitMQ RocketMQ、ActiveMQ区别和优劣势

##### 消费数据问题

1. 如何避免消息重复投递或重复消费？
2. 如何保证消息队列的高可用？
3. 如何处理消息丢失的问题？
4. 如何确保消息队列的幂等性？
5. 如何保证消息的顺序性？

##### Kafka副本机制以及选举策略

### [Redis](https://blog.csdn.net/ThinkWon/article/details/103522351)

##### 你项目中的并发量有多大？为什么选用Redis？

##### 单线程

1. Redis是单线程的还是多线程的？是单线程的为什么还支持每秒上万级别IO？

   Redis利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销。采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗

##### 时间复杂度

Redis读写的时间复杂度是多少？

> 查找和操作的时间复杂度都是O(1)

##### 数据结构&常用命令

1. String

   1. 常用命令

      set/get/decr/incr/mget

   2. 应用场景

   3. 补充说明

      String在redis内部存储默认就是一个字符串，被redisObject所引用，当遇到incr、decr等操作时会转成数值型进行计算，此时redisObject的encoding字段为int

2. Hash

   1. 常用命令

      hget/hset/hgetall

   2. 应用场景

      我们要存储一个用户信息对象数据，其中包括用户ID、用户姓名、年龄和生日，通过用户ID我们希望获取该用户的姓名或者年龄或者生日

3. List

   1. 常用命令

      lpush/rpush/lpop/rpop/lrange

   2. 应用场景

      Redis list的应用场景 非常多，也是Redis最重要的数据结构之一，比如twitter的关注列表，粉丝列表等都可以用Redis的list结构来实现

   3. 实现方式

      Redis list的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销，Redis内部的很多实现，包括发送缓冲队列等也都是用的这个数据结构

4. Set

   1. 常用命令

      sadd/spop/smembers/sunion

   2. 应用场景

      Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动**去重**的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的

   3. 实现方式

      set 的内部实现是一个 value永远为null的HashMap，实际就是通过计算hash的方式来快速去重的，这也是set能提供判断一个成员是否在集合内的原因

5. ZSet

   1. 常用命令

      zadd/zrange/zrem/zcard

   2. 应用场景

      Redis sorted set的使用场景与set类似，区别是set不是自动有序的，而sorted set可以通过用户额外提供一个优先级(score)的参数来为成员排序，并且是插入有序的，即自动排序

   3. 实现方式

      Redis sorted set的内部使用HashMap和跳跃表(SkipList)来保证数据的存储和有序，HashMap里放的是成员到score的映射，而跳跃表里存放的是所有的成员，排序依据是HashMap里存的score,使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单。

##### 应用场景

1. 队列

   Reids在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得Redis能作为一个很好的消息队列平台来使用

2.  排行榜/计数器

   Redis在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单，Redis只是正好提供了这两种数据结构。

##### 缓存失效策略

##### 过期键值对删除策略

1. 定时过期

   每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。

2. 惰性过期

   只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存

3. 定期过期

   每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。

##### 场景案例

1. 假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？

   使用keys指令可以扫出指定模式的key列表。

   对方接着追问：如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？

   这个时候你要回答redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。

2. 如果有大量的key需要设置同一时间过期，一般需要注意什么

   如果大量的key过期时间设置的过于集中，到过期的那个时间点，redis可能会出现短暂的卡顿现象。一般需要在时间上加一个随机值，使得过期时间分散一些。

##### 持久化方式

Redis 提供两种持久化机制 RDB（默认） 和 AOF 机制。

1. RDB

   RDB（Redis DataBase），RDB是Redis默认的持久化方式。按照一定的时间将内存的数据以快照的形式保存到硬盘中，对应产生的数据文件为dump.rdb。通过配置文件中的save参数来定义快照的周期。

   1. 优点
      1. 只有一个文件 dump.rdb，方便持久化
      2. 性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能
      3. 相对于数据集大时，比 AOF 的启动效率更高
   2. 缺点
      1. 数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失

2. AOF

   AOF持久化(即Append Only File持久化)，则是将Redis执行的每次写命令记录到单独的日志文件中，当重启Redis会重新将持久化的日志中文件恢复数据。

   1. 优点
      1. 数据安全，aof 持久化可以配置 appendfsync 属性，有 always，每进行一次 命令操作就记录到 aof 文件中一次。
      2. 通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。
   2. 缺点
      1. AOF 文件比 RDB 文件大，且恢复速度慢
      2. 数据集大的时候，比 rdb 启动效率低

##### 缓存和数据的一致性

##### Redis哨兵机制，选举策略？

##### Redis如何实现动态扩缩容？

##### Redis如何实现分布式锁？

##### 缓存雪崩、缓存击穿、缓存穿透

### 多线程

##### 线程池的实现原理

##### [多线程锁升级过程](https://blog.csdn.net/meism5/article/details/90321826)

1. [锁升级过程](https://juejin.cn/post/6890170757985337357)

   无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁

2. 锁分级别原因

   没有优化以前，synchronized是重量级锁（悲观锁），使用 wait 和 notify、notifyAll 来切换线程状态非常消耗系统资源；线程的挂起和唤醒间隔很短暂，这样很浪费资源，影响性能。所以 JVM 对 synchronized 关键字进行了优化，把锁分为 无锁、偏向锁、轻量级锁、重量级锁状态

##### 线程之间是如何调度的

##### 线程池的最大线程数目根据什么确定

- 如果是CPU密集型应用，则线程池大小设置为N+1 （N为CPU总核数）
- 如果是IO密集型应用，则线程池大小设置为2N+1 （N为CPU总核数）
- **线程等待时间(IO)所占比例越高，需要越多线程**。
- **线程CPU时间所占比例越高，需要越少线程**。

##### [sleep、yield、wait、join的区别](https://www.cnblogs.com/aspirant/p/8876670.html)

### Spring

##### Spring如何解决循环注入的问题

##### Spring框架中用到了哪些设计模式

##### 反射的原理，反射创建类实例的三种方式是什么？

### Docker

### MySQL

##### MySQL分库分表方案设计

### Zookeeper

### Jenkins

### Sonar

### XXLJob

### NGINX

1. NGINX工作原理以及常用配置
2. NGINX防盗链配置

### 设计模式

### 算法

### Vue

### 谷歌架构师面试都问哪些问题

### 真实业务场景提问

##### [接口限流实现方案](https://www.cnblogs.com/Chenjiabing/p/12534346.html)

1. 限流的常见几种算法

   1. 固定窗口计数器

      1. 图示

         ![img](https://gitee.com/chenjiabing666/Blog-file/raw/master/8ded7a2b90e1482093f92fff555b3615.png)

      2. 算法流程

         将时间划分为多个窗口

         在每个窗口内每有一次请求就将计数器加一 

         如果计数器超过了限制数量，则本窗口内所有的请求都被丢弃当时间到达下一个窗口时，计数器重置

      3. 缺点

         固定窗口计数器是最为简单的算法，但这个算法有时会让通过请求量允许为限制的两倍。考虑如下情况：限制 1 秒内最多通过 5 个请求，在第一个窗口的最后半秒内通过了 5 个请求，第二个窗口的前半秒内又通过了 5 个请求。这样看来就是在 1 秒内通过了 10 个请求

         ![img](https://gitee.com/chenjiabing666/Blog-file/raw/master/4d03e8e43a8edc3f32376d90e52b85f4.png)

   2. 滑动窗口计数器

      1. 图示

         ![img](https://gitee.com/chenjiabing666/Blog-file/raw/master/ae4d3cd14efb8dc7046d691c90264715.png)

      2. 算法流程

      3. 缺点

   3. 漏桶算法

      1. 图示

         ![img](https://gitee.com/chenjiabing666/Blog-file/raw/master/75938d1010138ce66e38c6ed0392f103.png)

      2. 算法流程

      3. 缺点

   4. 令牌桶算法

      1. 图示

         ![img](https://gitee.com/chenjiabing666/Blog-file/raw/master/eca0e5eaa35dac938c673fecf2ec9a93.png)

      2. 算法流程

      3. 缺点

2. 单体应用实现限流

   在传统的单体应用中限流只需要考虑到多线程即可，使用Google开源工具类guava即可。其中有一个RateLimiter专门实现了单体应用的限流，使用的是令牌桶算法。

3. 分布式应用实现接口限流

   1. 分布式限流和熔断现在有很多的现成的工具，比如Hystrix，Sentinel 等，但是还是有些企业不引用外来类库，因此就需要自己实现。
   2. Redis作为单线程多路复用的特性，很显然能够胜任这项任务

4. Redis实现接口限流

   

### 项目提问

1. 简历中不止一次提到了重新设计了系统、重新设计了基础框架，之前的架构设计是有哪些问题吗？
2. Kafka RabbitMQ RocketMQ区
3. 别在架构选型中为什么没有选用其他两种的消息队列？
4. 你的项目并发量有多大？数据量有多大？QPS有多少？什么样的业务场景要用到MQ？
5. 微服务 架构中声明式服务调⽤会带来哪些额外的成本？
6. 设计开发了基于mybatis-plus的代码⽣成⼯具？MP自身就有代码生成工具，你自己做了哪些设计开发？
7. 权限服务（控制到数据级别）是如何设计的？
8. 这个系统数据量，并发量大吗？有没有做过性能优化？
9. 简历上提到的七个网站，五个都访问不了？

