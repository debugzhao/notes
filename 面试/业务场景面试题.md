1. 实现一个高可用架构

2. [缓存双写一致性解决方案](https://zhuanlan.zhihu.com/p/59167071)

3. Spring 框架中都用到了哪些设计模式？

   1. 工厂模式：BeanFactory就是简单工厂模式的体现，用来创建对象的实例；
   2. 单例模式：Bean默认为单例模式。
   3. 代理模式：Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术；
   4. 模板方法：用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。
   5. 观察者模式：定义对象键一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知被制动更新，如Spring中listener的实现–ApplicationListener。

4. Spring面向切面编程(AOP)

   AOP(Aspect-Oriented Programming)，一般称为面向切面编程，作为面向对象的一种补充，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，**抽取并封装为一个可重用的模块**，这个模块被命名为“切面”（Aspect），减少系统中的重**复代码**，降低了模块间的**耦合度**，同时提高了系统的可维护性。可用于**权限认证、日志、事务处理**等。

   AOP实现的关键在于 **代理模式**，AOP代理主要分为**静态代理**和**动态代理**。静态代理的代表为AspectJ；动态代理则以Spring AOP为代表。

   （1）AspectJ是静态代理的增强，所谓静态代理，就是AOP框架会在编译阶段生成AOP代理类，因此也称为编译时增强，他会在编译阶段将AspectJ(切面)织入到Java字节码中，运行的时候就是增强之后的AOP对象。

   （2）Spring AOP使用的动态代理，所谓的动态代理就是说AOP框架不会去修改字节码，而是每次运行时在内存中临时为方法生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。

   静态代理与动态代理区别在于生成AOP代理对象的时机不同，相对来说AspectJ的静态代理方式具有更好的性能，但是AspectJ需要特定的编译器进行处理，而Spring AOP则无需特定的编译器处理。

   Spring AOP中的动态代理主要有两种方式，**JDK动态代理**和**CGLIB动态代理**

   Spring切面可以应用5种类型的通知：

   - 前置通知（Before）：在目标方法被调用之前调用通知功能；
   - 后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；
   - 返回通知（After-returning ）：在目标方法成功执行之后调用通知；
   - 异常通知（After-throwing）：在目标方法抛出异常后调用通知；
   - 环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。

5. == 和 equals 的区别是什么

   **==** : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。

   (基本数据类型 == 比较的是值，引用数据类型 == 比较的是内存地址)

   equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：

   情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。

   情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。

   ![image-20210527134747733](https://i.loli.net/2021/05/27/ukMa2FWsydTtI9b.png)

6. 什么是线程死锁

   死锁是指两个或两个以上的进程（线程）在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去

   如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。

   ![线程死锁](https://i.loli.net/2021/05/27/mPwQSkULHjirdDE.png)
