# JVM内存结构

<img src="https://cdn.jsdelivr.net/gh/Andre235/-community@master/src/image.1nlxuxgf8lds.png" alt="image" style="zoom: 50%;" />

#### 1.程序计数器

程序计数器：program counter register

Java源代码由JVM编译成**二进制字节码指令**，这些二进制字节码指令最终经过**解释器编译成CPU可以直接执行的机器码**

##### 1.1作用

**程序计数器负责记录下一条JVM指令的执行地址**

##### 1.2特点

1. 是线程私有的

   在多线程环境下，线程1的时间片用完之后需要保存当前线程的下一条JVM指令的执行地址，用以线程1抢占到CPU资源时继续从上次程序被阻塞状态的位置（从程序计数器中读取下一条JVM指令地址）继续运行。因此程序计数器必须设计成线程私有的

2. 不会存在内存溢出情况

```java
0: getstatic #20 // PrintStream out = System.out;
3: astore_1 // --
4: aload_1 // out.println(1);
5: iconst_1 // --
6: invokevirtual #26 // --
9: aload_1 // out.println(2);
10: iconst_2 // --
11: invokevirtual #26 // --
14: aload_1 // out.println(3);
15: iconst_3 // --
16: invokevirtual #26 // --
19: aload_1 // out.println(4);
20: iconst_4 // --
21: invokevirtual #26 // --
24: aload_1 // out.println(5);
25: iconst_5 // --
26: invokevirtual #26 // --
29: return
```

#### 2.虚拟机栈

##### 2.1定义

栈：每个线程运行时需要的内存

栈帧：每个方法运行时需要的内存（方法参数、局部变量、返回地址都会用到内存）

栈是先进后出的数据结构。线程运行时需要用到虚拟机栈，每创建一个线程就会开辟一块栈内存。每个栈由多个栈帧组成，一个栈帧对应着一次方法的调用

栈和栈帧对应的关系：每次调用一个方法会给这个方法划分一块栈帧空间，并且压入栈内；方法执行结束这个栈帧出栈并且释放栈帧对应的内存空间

每个线程只能有一个**活动栈帧**，对应着那个正在执行的方法。

##### 2.2 问题辨析

1. 垃圾回收是否涉及栈内存

   栈内存的消耗本质上是一次次的方法调用所占用的内存，随着方法的执行结束，栈帧会被弹出栈，内存会被自动回收掉，所以栈内存不涉及垃圾回收

2. 栈内存分配越大越好吗

   栈内存分配越大，反而会影响到分配的最大的线程数量

3. 分配栈内存参数

   ```shell
   # 分配1M的栈内存空间
   -Xss 1m # Linux系统默认的栈内积大小为1M
   ```

4. 方法内的局部变量是否是线程安全的

   1. 如果方法内局部变量逃离了方法的作用范围（引用类型的参数、引用类型的返回值），该方法不是线程安全的
   2. 如果局部变量引用了对象，并且逃离了方法的作用范围，需要考虑线程安全问题

   ```java
   /**
    * StringBuilder是线程私有变量，因此是线程安全的
    */
   private static void fun1() {
       StringBuilder sb = new StringBuilder();
       sb.append("1");
       sb.append("2");
       sb.append("3");
       System.out.println(sb.toString());
   }
   
   /**
    * StringBuilder可能存在多个线程调用sb，因此不是线程安全的
    */
   private static void fun2(StringBuilder sb) {
       sb.append("1");
       sb.append("2");
       sb.append("3");
   }
   
   /**
    * 返回值StringBuilder逃离了方法的作用范围 可能存在其他线程引用返回值，不是线程安全的
    * @return
    */
   private static StringBuilder fun3() {
       StringBuilder sb = new StringBuilder();
       sb.append("1");
       sb.append("2");
       sb.append("3");
       return sb;
   }
   ```

##### 2.3 栈内存溢出

1. 什么情况下会导致栈内存溢出

   1. 栈帧过多会导致栈内存溢出

      递归方法没有出口会导致栈内存溢出 `java.lang.StackOverflowError`

      外部框架问题也有可能导致栈溢出

      ```java
      /**
       * @author: lucas.zhao@kuhantech.com
       * @date: 2021/8/22 18:07
       * @description: 对象转json
       * 可能出现的问题：两个对象的循环引用问题会导致栈溢出
       * 解决方式：转换json时，可以选择性忽略转换某个json字段
       */
      public class JacksonStackOverFlowError {
          public static void main(String[] args) throws JsonProcessingException {
              Dept dept = new Dept();
              dept.setDeptName("Market");
      
              Emp emp1 = new Emp("lucas", dept);
              Emp emp2 = new Emp("natasha", dept);
              dept.setEmpList(Arrays.asList(emp1, emp2));
      
              ObjectMapper mapper = new ObjectMapper();
              System.out.println(mapper.writeValueAsString(dept));
          }
      }
      
      @Data
      @AllArgsConstructor
      @NoArgsConstructor
      class Dept {
          private String deptName;
          private List<Emp> empList;
      }
      
      @Data
      @AllArgsConstructor
      @NoArgsConstructor
      class Emp {
          private String empName;
          private Dept dept;
      }
      ```

   2. 栈帧过大会导致栈内存溢出

##### 2.4 线程运行诊断

1. CPU负载过高

   1.  用top命令定位哪个进程CPU占用过高

   2. 使用ps H -eo pid,tid,%cpu 定位哪个线程CPU占用过高

      ```shell
      # 查看线程CPU占用情况
      # H：打印进程数
      # -eo: 想要输出的信息
      ps H -eo pid,tid,%cpu
      ```

   3.  jstack 进程id

      可以根据线程id找到有问题的线程，然后进一步定位到有问题代码的行数

2. 程序运行很长时间没有结果

#### 3.本地方法栈

<img src="https://cdn.jsdelivr.net/gh/Andre235/-community@master/src/image.4t0gdt87xjc0.png" alt="image" style="zoom: 67%;" />

#### 4.堆

##### 4.1 定义

1. 概念

   通过new关键字创建的对象都会使用到堆内存

2. 特点

   1. 它是线程共享的，堆中所有对象都需要考虑线程安全问题
   2. 堆内存存在垃圾回收机制

##### 4.2 堆内存溢出

##### 4.3 堆内存诊断

#### 5.方法区

##### 5.1 定义

##### 5.2 组成

##### 5.3 组成内存溢出

##### 5.4 运行时常量池

##### 5.5 StringTable特性

##### 5.6 StringTable位置

##### 5.7 StringTable垃圾回收

##### 5.8 StringTable性能调优

#### 6 直接内存

##### 6.1 定义

##### 6.2 分配和回收原理
