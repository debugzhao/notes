# 深入理解Java虚拟机

## 第2章 Java内存区域与内存溢出异常

### 2.1概述

在Java程序中，内存管理机制由Java虚拟机负责管理，但是也正因为Java程序员把控制内存的权力交给了虚拟机，一旦出现<font color="red">内存泄漏</font>、<font color="red">内存溢出</font>等方面的问题，如果不了解虚拟机是怎么样使用内存的，那排查问题和修正问题将是非常艰难的工作。

本章节将会介绍Java虚拟机的各个区域，<font color="red">讲解这些区域的作用，服务的对象以及可能产生的问题</font>。

### 2.2 运行时数据区域

根据JVM规范，JVM所管理的内存区域将会包括以下几个运行时数据区域，它们分别是：

1. 方法区（线程共享数据区）
2. 堆内存（线程共享数据区）
3. 虚拟机栈（线程隔离数据区）
4. 本地方法栈（线程隔离数据区）
5. 程序计数器（线程隔离数据区）

<img src="https://cdn.jsdelivr.net/gh/Andre235/-community@master/src/image.2v4zu0awgmm0.webp" alt="image" style="zoom:67%;" />

#### 2.2.1 程序计数器

程序计数器是一块较小的内存空间，它可以看做是当前线程所执行的字节码的行号指示器。<font color="red">在Java虚拟机的概念模型中，字节码解释器工作时是需要改变这个计数器的值来确定下一条需要执行的字节码指令。</font>

由于Java虚拟机多线程的实现是通过多个线程轮流切换，抢占处理器执行时间来实现的。所以在任何一个时刻，任意一个处理器只能执行一个线程任务，因此线程切换后为了能够正确恢复到上一次执行任务的位置，线程内部需要程序计数器来保存当前执行位置。每个线程每部的程序计数器互相独立、互不影响。我们称这类内存区域为：<font color="red">线程私有内存区域</font>。

如果线程正在执行一个Java方法，则程序计数器保存的是当前正在执行的虚拟机字节码指令地址；如果线程执行的是本地（Native）方法，则程序计数器保存的值为空。

<font color="red">程序计数器区域不会出现OutOfMemoryError情况。</font>

> Java虚拟机多线程实现原理：多个线程轮流切换，抢占处理器执行时间来实现的。



#### 2.2.2 Java虚拟机栈

#### 2.2.3 本地方法栈

#### 2.2.4 Java堆

#### 2.2.5 方法区

#### 2.2.6 运行时常量池

#### 2.2.7 直接内存

### 2.3 HotSpot 虚拟机对象探秘

### 2.4 实战：OutOfMemoryError异常

### 2.5 本章小节

















<font color="red"></font>