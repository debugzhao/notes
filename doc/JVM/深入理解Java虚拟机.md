# 深入理解Java虚拟机

## 第2章 Java内存区域与内存溢出异常

### 2.1概述

在Java程序中，内存管理机制由Java虚拟机负责管理，但是也正因为Java程序员把控制内存的权力交给了虚拟机，一旦出现<font color="red">内存泄漏</font>、<font color="red">内存溢出</font>等方面的问题，如果不了解虚拟机是怎么样使用内存的，那排查问题和修正问题将是非常艰难的工作。

本章节将会介绍Java虚拟机的各个区域，<font color="red">讲解这些区域的作用，服务的对象以及可能产生的问题</font>。

### 2.2 运行时数据区域

根据JVM规范，JVM所管理的内存区域将会包括以下几个运行时数据区域，它们分别是：

1. 方法区（线程共享数据区）
2. 堆内存（线程共享数据区）
3. 虚拟机栈（线程隔离数据区）
4. 本地方法栈（线程隔离数据区）
5. 程序计数器（线程隔离数据区）

<img src="https://cdn.jsdelivr.net/gh/Andre235/-community@master/src/image.2v4zu0awgmm0.webp" alt="image" style="zoom:67%;" />

#### 2.2.1 程序计数器

程序计数器是一块较小的内存空间，它可以看做是当前线程所执行的字节码的行号指示器。<font color="red">在Java虚拟机的概念模型中，字节码解释器工作时是需要改变这个计数器的值来确定下一条需要执行的字节码指令。</font>

由于Java虚拟机多线程的实现是通过多个线程轮流切换，抢占处理器执行时间来实现的。所以在任何一个时刻，任意一个处理器只能执行一个线程任务，因此线程切换后为了能够正确恢复到上一次执行任务的位置，线程内部需要程序计数器来保存当前执行位置。每个线程每部的程序计数器互相独立、互不影响。我们称这类内存区域为：<font color="red">线程私有内存区域</font>。

如果线程正在执行一个Java方法，则程序计数器保存的是当前正在执行的虚拟机字节码指令地址；如果线程执行的是本地（Native）方法，则程序计数器保存的值为空。

**程序计数器异常情况：**

<font color="red">程序计数器区域不会出现OutOfMemoryError情况。</font>

> Java虚拟机多线程实现原理：多个线程轮流切换，抢占处理器执行时间来实现的。

#### 2.2.2 Java虚拟机栈

<font color="red">与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期和线程的生命周期相同。</font>虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行时，Java虚拟机栈都会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。<font color="red">每个方法被调用直至执行完毕的过程，就对应着一个栈帧从入栈到出栈的过程。</font>

局部变量表存放着编译器可知的各种Java虚拟机基本数据类型、对象应用、返回地址。这种数据类型在局部变量表中的存储空间以`局部变量插槽`的形式表示。局部变量表所需要的内存空间在编译器就已经完成分配。当进入一个方法时，这个方法在栈帧中所需要的局部变量表空间是确定的，在方法执行期间也不会改变局部变量表的大小（这里的大小指的是插槽的数量）。

**虚拟机栈异常情况：**

1. StackOverflowError异常

   当线程请求的栈的深度超过虚拟机所允许的最大栈的深度，就会抛出StackOverflowError异常。

2. OutOfMemoryError异常

   当栈空间扩展无法申请到足够的内存时就会抛出OutOfMemoryError异常。

#### 2.2.3 本地方法栈

本地方法栈与虚拟机栈提供的作用是非常相似的，其区别就是虚拟机栈执行的是Java方法，本地方法栈执行的是本地Native方法。

#### 2.2.4 Java堆

Java堆内存是JVM管理的最大的一块内存区域，并且<font color="red">堆内存是被所有线程共享的</font>，由虚拟机启动时创建。Java堆内存的唯一目的就是存放对象实例，<font color="red">Java程序中几乎所有的对象实例都是在堆内存上分配的</font>。

将Java堆内存细分的目的是为了更好地回收内存、或者更快地分配内存。

Java堆内存可以处于物理上不连续的内存空间，逻辑是它被视为连续的。但是对于大对象（数组对象）多数虚拟机出于实现简单、存储高效的考虑，很可能会要求大对象存储在连续的内存空间。

目前主流的Java虚拟机的堆内存都是可以扩展的（<font color="red">由参数-Xmx和-Xms设定</font>）

**异常情况：**

1. OutOfMemoryError异常

   如果对内存没有足够多的内存来分配对象，并且堆内存内存不能再扩展时，JVM将会抛出OutOfMemoryError异常。

#### 2.2.5 方法区

方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的`类型信息`、`常量`、`静态变量`、即时编译器编译后的`代码缓存`等数据。

垃圾收集行为在这个区域的 确是比较少出现的，这区域的内存回 收目标主要是针对常量池的回收和对类型的卸载。

#### 2.2.6 运行时常量池

运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字 段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译期生 成的各种`字面量`与`符号引用`，这部分内容将在类加载后存放到方法区的运行时常量池中。

**异常情况：**

既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出<font color="red">OutOfMemoryError异常。</font>

#### 2.2.7 直接内存

直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中 定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现

**异常情况：**

一般服务 器管理员配置虚拟机参数时，会根据实际内存去设置-Xmx等参数信息，但经常忽略掉直接内存，使得 各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现<font color="red"> OutOfMemoryError异常</font>

### 2.3 HotSpot 虚拟机对象探秘

笔者以最常用的虚拟机HotSpot和最常用 的内存区域Java堆为例，深入探讨一下HotSpot虚拟机在Java堆中对象分配、布局和访问的全过程。

#### 2.3.1 对象的创建

1. 类加载

   当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到 一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那 必须先执行相应的类加载过程。

2. 为新生对象分配内存

   在类加载检查通过后，接下来虚拟机将为新生对象分配内存。

   常见的分配的内存的方式有两种：指针碰撞方式、空闲列表方式

   1. <font color="red">指针碰撞方式</font>

      如果Java堆内存是规整的，所有被使用过的内存都被放在一 边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那 个指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”（Bump The Pointer）。

   2. <font color="red">空闲列表方式</font>

      但如果Java堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那 就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分 配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称 为“空闲列表”（Free List）。

3. 分派到的内存空间初始化零值

   内存分配完成之后，虚拟机必须将分配到的内存空间（但不包括对象头）都初始化为零值。这步操作保证了对象的实例字段 在Java代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型所对应的零值。

4. 为对象进行必要的设置

   Java虚拟机还要对对象进行必要的设置，例如这个对象是`哪个类的实例`、如何才能找到类的`元数据信息`、对象的`哈希码`、对象的`GC分代年龄`等信息。

5. 对象init（执行构造方法）

   new指令之后会接着执行 ()方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来。

#### 2.3.2 对象的内存布局

#### 2.3.3 对象的访问定位

### 2.4 实战：OutOfMemoryError异常

### 2.5 本章小节

















<font color="red"></font>