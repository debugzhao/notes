## 内存区域与内存溢出异常

#### 1.运行时数据区域

这些运行时数据区各有各自的用途，以及创建时间和销毁时间。有的运行时数据区随着虚拟机进程的启动而一直存在，有的数据区域则是依赖用户进程的启动和结束而创建和销毁

**Java运行时内存区域模型图**

<img src="https://i.loli.net/2020/09/30/L2n415UPcak7EMB.png" alt="Java运行时数据区内存模型" style="zoom:80%;" />

##### 2.程序计数器

1. 概念

   程序计数器是一块较小的内存空间，它可以看做是当前线程所执行的字节码的行号指示器，在Java虚拟机模型中，字节码解释器工作时就是通过改变计数器的值来确定下一条要执行的字节码指令

2. 作用

   它是程序控制流的指示器，程序的分支、循环、跳转、异常处理、线程恢复等基本功能都需要通过程序计数器来完成。

   Java虚拟机的多线程的实现是通过多个线程轮流切换，分配处理机的执行时间来完成的，在任何一个确定的时刻 一个处理机（对多核处理器来说是一个内核）只会执行一个线程中的指令。*因此，为了线程切换后能过恢复到正确的执行位置，每个线程内部都需要一个独立的程序计数器来保存当前线程所执行到得字节码位置*

3. 线程私有

   各个线程的程序计数器互不影响，独立存储，我们称这块内存为线程私有内存

4.  执行不同类型方法时

   如果线程执行的是Java方法，程序计数器记录的是当前线程执行的字节码指令地址；如果执行的是本地 `native` 方法，这个计数器则为空

5. 异常情况

   该内存区域不会出现OOM

##### 3.Java虚拟机栈

Java虚拟机栈是线程私有的，它的生命周期和线程的生命周期相同。Java虚拟机栈描述的是方法执行时在线程中的内存模型：每个方法执行时都会在虚拟机栈中创建一个栈帧（stack frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法被调用直至执行完毕的过程中都对应着一个栈帧在虚拟机栈中入栈到出栈的过程。

虚拟机栈更多的指的是局部变量表部分。

局部变量表存放了编译器可知的各种Java虚拟机基本数据类型（boolean、byte、char、short、int、float、long、double）和对象引用（对象应用不等同于对象本身，可能指的是一个指向对象起始地址的引用指针）。

局部变量表所需要的内存空间在编译期完成分配， 当进入一个方法时，这个方法在栈帧中所需要的局部变量空间是完全确定的，并且不会随着方法的运行而改变大小。

**异常**

1. 如果线程请求的栈的深度大于虚拟机所允许的最大深度，程序将会抛出栈溢出异常 `StackOverFlowError`
2. 如果Java虚拟机栈容量可以动态扩展，当栈扩展到无法申请足够多的内存时会抛出内存溢出异常 `OutOfMemoryError`

#### 4.本地方法栈

##### 4.1概念

本地方法栈 `Native Method Stack`与虚拟机栈所发挥的作用是非常类似的，不同的是虚拟机栈只为虚拟机提供执行`Java`方法服务（即执行字节码指令），但是本地方法栈只为虚拟机提供`Native`本地方法服务。

##### 4.2异常

1. 栈溢出异常
2. 内存溢出异常

#### 5.堆内存

1.  概念

   Java堆是虚拟机管理的<font color="red">最大的一块内存区域</font>，同时也是所有线程<font color="red">内存共享的一块区域</font>，堆内存的唯一目的就是<font color="red">存放对象的实例</font>，**几乎**所有的对象实例都在堆内存上分配内存。同时也是垃圾回收 `Garbage Collected Heap` 的地方。

   为了提高给对象分配内存的效率，原本由所有线程共享的Java堆可以划分成多个线程私有的分配缓冲区。将Java堆内存细分的目的是为了更好地回收内存或者更快地分配内存。

   堆内存可以处于物理上不连续的内存空间，但是逻辑上它应该被视为连续的内存空间。

2. 堆内存扩展参数

   通过-Xmx和-Xms参数可以配置堆内存的扩展容量

3. 异常情况

   在堆内存中如果没有足够的内存完成实例的分配，并且堆内存也无法再扩展时会抛出OOM异常。

4. [JVM的Xms和Xmx参数设置为相同值有什么好处？](https://cloud.tencent.com/developer/article/1695047)

   1. Xmx、Xms参数的定义

      -Xms：堆内存的最小Heap值，默认为物理内存的1/64，但小于1G。

      -Xmx：堆内存的最大Heap值，默认为物理内存的1/4。

   2. 内存情况的变化

      常规的JVM参数使用如下：

      ```shell
      java -Xms512m -Xmx1g
      ```

      在这种配置下，JVM启动时会分配512M的堆内存空间，随着程序的执行，所需的堆空间越来越大，则会逐渐增大堆内存空间，直到Xmx参数指定的堆最大空间1G。

      当堆内存使用率降低，则会逐渐减小该内存区域的大小。整个过程看似非常合理，但为什么很多生产环境却也将两个值配置为相同的值

   3. JVM垃圾回收的不足

      当堆内存使用情况变化时，并不是单纯的扩大和缩小堆内存就完事了。在此之前还会执行GC（垃圾回收）操作。如果-Xms起初值设置的比较小，那么就频繁触发GC操作。当GC操作无法释放更多内存时，才会进行内存的扩充。

      我们都知道GC操作是需要耗时的，而且Full GC会引起“Stop the World”，也就是说会引起线程停止，不可避免就会引起性能问题。

   4. 相同值的好处

      面对上面的问题，为了避免在生产环境由于heap内存扩大或缩小导致应用停顿，降低延迟，同时避免每次垃圾回收完成后JVM重新分配内存。所以，-Xmx和-Xms一般都是设置相等的。

#### 6.方法区

##### 6.1概念

方法区和堆一样，可以处于物理上不连续的内存空间上；可以选择固定大小或者可扩展的内存空间

##### 6.2作用

方法区主要进行常量的回收和类型的卸载，但是这块的内存回收效果不是很理想

##### 6.3异常

在方法区内如果无法申请到足够多的内存时就会抛出内存溢出异常







#### <font color="red"></font>



