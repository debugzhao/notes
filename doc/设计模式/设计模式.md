### 一.七大原则

#### 开闭原则

1. 原则

   该原则规定在进行类的维护时尽量遵循对扩展开放，对修改关闭

#### 里氏替换原则

1. 原则

   子类可以扩展父类的功能，但是不能改变父类原有的功能

#### 合成复用原则

1. 原则

   该原则要求软件在复用时，尽量有限考虑组合/聚合方式来实现复用，其次再考虑用继承方式来实现复用。如何要以继承方式来实现复用则必要遵守里氏替换原则。合成复用原则和里氏替换原则两者相辅相成，都是对开闭原则规范的具体实现

2. 分类

   ​	通常类的复用分为两种，一种是继承复用，一种是组合/聚合复用

   1. 继承复用（缺点）

      1. 破坏了类的封装性

         因为继承会将父类的实现细节暴露给子类，父类对子类完全透明，因此继承复用也被称之为`白箱复用`

      2. 耦合度太高

         父类与子类之间的耦合度太高，父类的实现的任何改变都是影响到子类的变化，这不利于类的扩展和维护

      3. 限制了复用的灵活性

         子类从父类继承而来的实现是静态的，它在编译期就已经定义好了，因此不能改变

   2. 组合/聚合复用（优点）

      1. 维持了的封装性
      2. 降低了类的耦合度
      3. 提高了复用的灵活性

3. 实现方式

   合成复用原则是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用

### 二.创建型模式.

#### 创建型模式的特点和分类

1. 特点

   创建型模式的主要关注点是“怎样创建对象？”，它的主要特点是“将对象的创建与使用分离”。这样可以降低系统的耦合度，使用者不需要关注对象的创建细节，对象的创建由相关的工厂来完成

2. 分类

   1. 单例模式

      某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式

   2. 原型模式

      将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例

   3. 工厂方法模式

      定义一个用于创建产品的接口，由子类决定生产什么产品

   4. 抽象工厂模式

      提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品

   5. 建造者模式

      将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象

#### 单例模式

1. 单例模式特点

   1. 单例类中只有一个实例对象
   2. 该实例对象只能由该单例类创建
   3. 单例类对外提供一个访问该单例的全局访问点

2. 优点

   1. 单例模式可以保证内存里只有一个实例，减少了内存的开销
   2. 可以避免对资源的多重占用
   3. 单例模式设置全局访问点，可以优化和共享资源的访问

3. 引用场景

   1. 需要频繁创建的一些类，使用单例可以降低系统的内存压力，减少 GC
   2. 某类只要求生成一个对象的时候，如一个班中的班长、每个人的身份证号等
   3. 某类需要频繁实例化，而创建的对象又频繁被销毁的时候，如多线程的线程池、网络连接池等
   4. 当对象需要被共享的场合

4. 懒汉式和饿汉式

   1. 懒汉式

      什么时候调用getInstance方法，什么时候就创建该实例，懒汉式是非线程安全的，因此在设计的时候应该保证线程安全性

   2. 饿汉式

      类一加载就创建该单例，保证了在调用getInstance方法之前该单例就已经创建好了。因此饿汉式是线程安全的

#### 原型模式

1. 概念：

   用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象

   *原型对象需要实现Cloneable接口，否则会抛出异常*

2. 优点

   [Java](http://c.biancheng.net/java/) 自带的原型模式基于内存二进制流的复制，在性能上比直接 new 一个对象更加优良

   可以使用深克隆方式保存对象的状态

3. 分类

   1. 浅克隆

   2. 深克隆

      在Java中如果需要实现对象的深拷贝，可以通过序列化再反序列化的方式实现（将一个对象保存到流中，然后再从流中读取出来）。

      序列化实现深拷贝的原理：通过序列化实现的拷贝不仅可以复制对象本身，还可以复制原型对象的引用类型的成员变量

      *序列化对象需要实现Serializable接口*

#### 工厂方法模式



#### 抽象工厂模式

#### 建造者模式

### 三.结构型模式

### 四.行为型模式